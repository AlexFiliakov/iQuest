"""Comprehensive tests for statistics calculator module."""

import pytest
from datetime import date, datetime, timedelta
from unittest.mock import Mock, patch
import pandas as pd
import numpy as np
from scipy import stats

from src.statistics_calculator import (
    StatisticsCalculator, StatisticsResult, StatisticsSummary,
    DistributionAnalysis, TrendStatistics, OutlierAnalysis
)


class TestStatisticsModels:
    """Test statistics model classes."""
    
    def test_statistics_result_creation(self):
        """Test StatisticsResult creation."""
        result = StatisticsResult(
            metric_type="steps",
            period_start=date(2023, 1, 1),
            period_end=date(2023, 1, 31),
            count=31,
            mean=8500.5,
            median=8300,
            mode=8000,
            std_dev=1250.3,
            variance=1563250.09,
            min_value=5000,
            max_value=12000,
            range=7000,
            percentiles={
                25: 7500,
                50: 8300,
                75: 9500,
                90: 10500,
                95: 11000
            },
            skewness=0.35,
            kurtosis=2.8
        )
        
        assert result.mean == 8500.5
        assert result.percentiles[75] == 9500
        assert result.is_normally_distributed(alpha=0.05) is True  # Based on skewness/kurtosis
        
    def test_distribution_analysis(self):
        """Test DistributionAnalysis creation."""
        analysis = DistributionAnalysis(
            distribution_type="normal",
            parameters={"mu": 8000, "sigma": 1000},
            goodness_of_fit={
                "chi_square": 12.5,
                "p_value": 0.15,
                "degrees_of_freedom": 10
            },
            is_normal=True,
            is_skewed=False,
            outlier_count=3,
            confidence_intervals={
                90: (7200, 8800),
                95: (7000, 9000),
                99: (6500, 9500)
            }
        )
        
        assert analysis.distribution_type == "normal"
        assert analysis.is_normal is True
        assert analysis.confidence_intervals[95] == (7000, 9000)
        
    def test_trend_statistics(self):
        """Test TrendStatistics creation."""
        trend = TrendStatistics(
            slope=50.5,
            intercept=8000,
            r_squared=0.85,
            p_value=0.001,
            trend_direction="increasing",
            strength="strong",
            forecast_next_period=8550,
            confidence_interval=(8400, 8700),
            seasonality_detected=True,
            seasonal_pattern="weekly"
        )
        
        assert trend.slope == 50.5
        assert trend.is_significant(alpha=0.05) is True
        assert trend.strength == "strong"
        
    def test_outlier_analysis(self):
        """Test OutlierAnalysis creation."""
        outliers = OutlierAnalysis(
            method="iqr",
            outliers=[
                {"date": date(2023, 1, 5), "value": 15000, "z_score": 3.2},
                {"date": date(2023, 1, 15), "value": 2000, "z_score": -2.8}
            ],
            threshold=1.5,
            lower_fence=5000,
            upper_fence=11000,
            outlier_percentage=6.5
        )
        
        assert len(outliers.outliers) == 2
        assert outliers.outlier_percentage == 6.5
        assert outliers.has_outliers() is True


class TestStatisticsCalculator:
    """Test statistics calculator functionality."""
    
    @pytest.fixture
    def calculator(self):
        """Create statistics calculator."""
        return StatisticsCalculator()
    
    @pytest.fixture
    def sample_data(self):
        """Create sample health data."""
        np.random.seed(42)
        dates = pd.date_range(start='2023-01-01', periods=100, freq='D')
        
        # Create realistic step data with trend and weekly pattern
        trend = np.linspace(7000, 9000, 100)
        weekly_pattern = np.array([1.1, 1.15, 1.2, 1.15, 1.1, 0.9, 0.85] * 15)[:100]
        noise = np.random.normal(0, 500, 100)
        
        steps = trend * weekly_pattern + noise
        steps = np.clip(steps, 2000, 15000)
        
        return pd.DataFrame({
            'date': dates,
            'value': steps,
            'type': 'steps'
        })
    
    def test_calculate_basic_statistics(self, calculator, sample_data):
        """Test basic statistics calculation."""
        stats = calculator.calculate_basic_statistics(sample_data['value'])
        
        assert isinstance(stats, StatisticsResult)
        assert stats.count == 100
        assert 7000 <= stats.mean <= 9000
        assert stats.std_dev > 0
        assert stats.min_value >= 2000
        assert stats.max_value <= 15000
        
        # Check percentiles
        assert stats.percentiles[25] < stats.percentiles[50] < stats.percentiles[75]
        
    def test_calculate_from_dataframe(self, calculator, sample_data):
        """Test calculating statistics from DataFrame."""
        result = calculator.calculate_from_dataframe(
            df=sample_data,
            metric_type='steps',
            value_column='value'
        )
        
        assert result.metric_type == 'steps'
        assert result.period_start == sample_data['date'].min().date()
        assert result.period_end == sample_data['date'].max().date()
        
    def test_distribution_analysis(self, calculator):
        """Test distribution analysis."""
        # Normal distribution
        normal_data = np.random.normal(100, 15, 1000)
        normal_analysis = calculator.analyze_distribution(normal_data)
        
        assert normal_analysis.is_normal is True
        assert abs(normal_analysis.parameters['mu'] - 100) < 2
        assert abs(normal_analysis.parameters['sigma'] - 15) < 2
        
        # Skewed distribution
        skewed_data = np.random.exponential(10, 1000)
        skewed_analysis = calculator.analyze_distribution(skewed_data)
        
        assert skewed_analysis.is_skewed is True
        
    def test_trend_analysis(self, calculator, sample_data):
        """Test trend analysis."""
        trend = calculator.analyze_trend(
            data=sample_data,
            date_column='date',
            value_column='value'
        )
        
        assert isinstance(trend, TrendStatistics)
        assert trend.trend_direction == "increasing"
        assert trend.r_squared > 0.5  # Moderate fit due to noise
        assert trend.p_value < 0.05  # Significant trend
        
    def test_outlier_detection(self, calculator):
        """Test outlier detection methods."""
        # Create data with outliers
        data = np.random.normal(100, 10, 100)
        data = np.append(data, [200, 250, 10, 5])  # Add outliers
        
        # IQR method
        iqr_outliers = calculator.detect_outliers(data, method='iqr')
        assert len(iqr_outliers.outliers) >= 2
        
        # Z-score method
        zscore_outliers = calculator.detect_outliers(data, method='zscore', threshold=3)
        assert len(zscore_outliers.outliers) >= 2
        
        # Modified Z-score (more robust)
        modified_outliers = calculator.detect_outliers(data, method='modified_zscore')
        assert len(modified_outliers.outliers) >= 2
        
    def test_time_series_statistics(self, calculator, sample_data):
        """Test time series specific statistics."""
        ts_stats = calculator.calculate_time_series_statistics(
            data=sample_data,
            date_column='date',
            value_column='value'
        )
        
        assert 'autocorrelation' in ts_stats
        assert 'seasonality' in ts_stats
        assert 'stationarity' in ts_stats
        
        # Check for weekly seasonality
        assert ts_stats['seasonality']['detected'] is True
        assert ts_stats['seasonality']['period'] == 7  # Weekly
        
    def test_comparative_statistics(self, calculator):
        """Test comparative statistics between groups."""
        # Create two groups
        group1 = np.random.normal(100, 10, 100)
        group2 = np.random.normal(110, 12, 100)
        
        comparison = calculator.compare_groups(
            group1=group1,
            group2=group2,
            test='t-test'
        )
        
        assert 'statistic' in comparison
        assert 'p_value' in comparison
        assert comparison['p_value'] < 0.05  # Groups are different
        assert comparison['effect_size'] > 0.5  # Medium effect
        
    def test_rolling_statistics(self, calculator, sample_data):
        """Test rolling window statistics."""
        rolling_stats = calculator.calculate_rolling_statistics(
            data=sample_data,
            window=7,
            value_column='value'
        )
        
        assert len(rolling_stats) == len(sample_data)
        assert 'rolling_mean' in rolling_stats.columns
        assert 'rolling_std' in rolling_stats.columns
        assert 'rolling_min' in rolling_stats.columns
        assert 'rolling_max' in rolling_stats.columns
        
        # Check that rolling mean smooths the data
        assert rolling_stats['rolling_std'].mean() < sample_data['value'].std()
        
    def test_statistics_summary(self, calculator, sample_data):
        """Test creating comprehensive statistics summary."""
        summary = calculator.create_summary(
            data=sample_data,
            metric_type='steps',
            include_distribution=True,
            include_trend=True,
            include_outliers=True
        )
        
        assert isinstance(summary, StatisticsSummary)
        assert summary.basic_stats is not None
        assert summary.distribution is not None
        assert summary.trend is not None
        assert summary.outliers is not None
        
    def test_percentile_calculation(self, calculator):
        """Test percentile calculation methods."""
        data = np.arange(1, 101)  # 1 to 100
        
        # Standard percentiles
        p50 = calculator.calculate_percentile(data, 50)
        assert p50 == 50.5  # Median of 1-100
        
        # Multiple percentiles
        percentiles = calculator.calculate_percentiles(
            data, 
            [10, 25, 50, 75, 90]
        )
        assert percentiles[10] == 10.9
        assert percentiles[90] == 90.1
        
    def test_confidence_intervals(self, calculator):
        """Test confidence interval calculation."""
        data = np.random.normal(100, 10, 1000)
        
        # 95% confidence interval
        ci_95 = calculator.calculate_confidence_interval(data, confidence=0.95)
        assert 99 < ci_95[0] < 100 < ci_95[1] < 101
        
        # 99% confidence interval (wider)
        ci_99 = calculator.calculate_confidence_interval(data, confidence=0.99)
        assert ci_99[0] < ci_95[0]
        assert ci_99[1] > ci_95[1]
        
    def test_correlation_analysis(self, calculator):
        """Test correlation analysis between metrics."""
        # Create correlated data
        x = np.random.normal(100, 10, 100)
        y = 2 * x + np.random.normal(0, 5, 100)
        
        data = pd.DataFrame({
            'metric1': x,
            'metric2': y
        })
        
        correlation = calculator.calculate_correlation(
            data,
            method='pearson'
        )
        
        assert correlation['metric1']['metric2'] > 0.9  # Strong positive correlation
        
        # Spearman correlation (rank-based)
        spearman = calculator.calculate_correlation(
            data,
            method='spearman'
        )
        
        assert spearman['metric1']['metric2'] > 0.9
        
    def test_seasonal_decomposition(self, calculator):
        """Test seasonal decomposition."""
        # Create data with clear seasonality
        dates = pd.date_range('2023-01-01', periods=365, freq='D')
        trend = np.linspace(100, 200, 365)
        seasonal = 10 * np.sin(2 * np.pi * np.arange(365) / 7)  # Weekly pattern
        noise = np.random.normal(0, 2, 365)
        
        data = pd.DataFrame({
            'date': dates,
            'value': trend + seasonal + noise
        })
        
        decomposition = calculator.decompose_time_series(
            data,
            period=7  # Weekly
        )
        
        assert 'trend' in decomposition
        assert 'seasonal' in decomposition
        assert 'residual' in decomposition
        
        # Trend should be increasing
        assert decomposition['trend'].iloc[-1] > decomposition['trend'].iloc[0]


class TestAdvancedStatistics:
    """Test advanced statistical methods."""
    
    @pytest.fixture
    def calculator(self):
        """Create statistics calculator."""
        return StatisticsCalculator()
    
    def test_bootstrap_confidence_intervals(self, calculator):
        """Test bootstrap confidence interval estimation."""
        data = np.random.normal(100, 15, 50)  # Small sample
        
        boot_ci = calculator.bootstrap_confidence_interval(
            data,
            statistic='mean',
            confidence=0.95,
            n_iterations=1000
        )
        
        # Should be wider than parametric CI due to small sample
        param_ci = calculator.calculate_confidence_interval(data, 0.95)
        assert (boot_ci[1] - boot_ci[0]) >= (param_ci[1] - param_ci[0])
        
    def test_hypothesis_testing(self, calculator):
        """Test hypothesis testing functionality."""
        # One-sample t-test
        data = np.random.normal(105, 10, 100)  # Mean slightly above 100
        
        result = calculator.hypothesis_test(
            data=data,
            test_type='one_sample_t',
            null_value=100
        )
        
        assert result['p_value'] < 0.05  # Reject null hypothesis
        assert result['test_statistic'] > 0  # Mean is greater than 100
        
    def test_change_point_detection(self, calculator):
        """Test change point detection in time series."""
        # Create data with change point
        data1 = np.random.normal(100, 10, 50)
        data2 = np.random.normal(120, 10, 50)  # Shift in mean
        data = np.concatenate([data1, data2])
        
        dates = pd.date_range('2023-01-01', periods=100)
        ts_data = pd.DataFrame({'date': dates, 'value': data})
        
        change_points = calculator.detect_change_points(ts_data)
        
        assert len(change_points) >= 1
        # Should detect change around index 50
        assert any(45 <= cp['index'] <= 55 for cp in change_points)
        
    def test_multivariate_statistics(self, calculator):
        """Test multivariate statistical analysis."""
        # Create multivariate data
        n_samples = 200
        mean = [100, 50, 75]
        cov = [[100, 30, 20],
               [30, 50, 15],
               [20, 15, 40]]
        
        data = np.random.multivariate_normal(mean, cov, n_samples)
        df = pd.DataFrame(data, columns=['metric1', 'metric2', 'metric3'])
        
        # Principal component analysis
        pca_result = calculator.principal_component_analysis(df, n_components=2)
        
        assert pca_result['n_components'] == 2
        assert pca_result['explained_variance_ratio'].sum() > 0.8
        
        # Multivariate normality test
        normality = calculator.test_multivariate_normality(df)
        assert 'p_value' in normality
        
    def test_robust_statistics(self, calculator):
        """Test robust statistical measures."""
        # Data with outliers
        data = np.concatenate([
            np.random.normal(100, 10, 95),
            [500, 600, -100, -200, 1000]  # Extreme outliers
        ])
        
        robust_stats = calculator.calculate_robust_statistics(data)
        
        # Robust measures should be less affected by outliers
        assert 95 < robust_stats['median'] < 105
        assert 8 < robust_stats['mad'] < 15  # Median absolute deviation
        assert 95 < robust_stats['trimmed_mean'] < 105
        
        # Compare with regular mean
        regular_mean = np.mean(data)
        assert abs(robust_stats['median'] - 100) < abs(regular_mean - 100)


def test_statistics_calculator_integration():
    """Test complete statistics calculation workflow."""
    calculator = StatisticsCalculator()
    
    # Create realistic health data
    np.random.seed(42)
    dates = pd.date_range('2022-01-01', periods=365, freq='D')
    
    # Steps with trend, weekly pattern, and occasional outliers
    base_steps = 8000
    trend = np.linspace(0, 1000, 365)
    weekly_pattern = []
    for i in range(365):
        day_of_week = dates[i].dayofweek
        if day_of_week < 5:  # Weekday
            weekly_pattern.append(1.0)
        else:  # Weekend
            weekly_pattern.append(0.8)
    
    steps = base_steps + trend + np.array(weekly_pattern) * 1000
    steps += np.random.normal(0, 500, 365)
    
    # Add some outliers
    outlier_indices = [50, 150, 250]
    for idx in outlier_indices:
        steps[idx] = np.random.choice([2000, 15000])  # Very low or very high
    
    health_data = pd.DataFrame({
        'date': dates,
        'steps': steps,
        'heart_rate': np.random.normal(65, 8, 365),
        'sleep_hours': np.random.normal(7.5, 1, 365)
    })
    
    # 1. Calculate comprehensive statistics
    summary = calculator.create_comprehensive_summary(
        data=health_data,
        metrics=['steps', 'heart_rate', 'sleep_hours']
    )
    
    # 2. Verify basic statistics
    steps_stats = summary['steps']['basic']
    assert 7000 < steps_stats.mean < 10000
    assert steps_stats.count == 365
    
    # 3. Verify trend detection
    steps_trend = summary['steps']['trend']
    assert steps_trend.trend_direction == "increasing"
    assert steps_trend.slope > 0
    
    # 4. Verify outlier detection
    steps_outliers = summary['steps']['outliers']
    assert len(steps_outliers.outliers) >= 3
    
    # 5. Verify seasonality detection
    seasonality = summary['steps']['seasonality']
    assert seasonality['detected'] is True
    assert seasonality['period'] == 7  # Weekly pattern
    
    # 6. Cross-metric analysis
    correlations = calculator.analyze_cross_metric_relationships(
        health_data,
        metrics=['steps', 'heart_rate', 'sleep_hours']
    )
    
    # 7. Generate insights
    insights = calculator.generate_statistical_insights(summary)
    
    assert len(insights) > 0
    assert any('trend' in insight.lower() for insight in insights)
    assert any('outlier' in insight.lower() for insight in insights)