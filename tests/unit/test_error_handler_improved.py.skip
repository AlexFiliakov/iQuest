"""
Comprehensive test suite for Error Handler utilities with high coverage.
Tests all decorators, custom exceptions, and error context management.
"""

import pytest
import logging
from unittest.mock import Mock, patch, call
import traceback

from src.utils.error_handler import (
    AppleHealthError, DataImportError, DataValidationError, 
    DatabaseError, ConfigurationError,
    error_handler, safe_file_operation, safe_database_operation,
    ErrorContext, format_error_message
)


class TestCustomExceptions:
    """Test custom exception classes."""
    
    def test_apple_health_error(self):
        """Test base AppleHealthError exception."""
        error = AppleHealthError("Base error message")
        assert str(error) == "Base error message"
        assert isinstance(error, Exception)
    
    def test_data_import_error(self):
        """Test DataImportError exception."""
        error = DataImportError("Import failed")
        assert str(error) == "Import failed"
        assert isinstance(error, AppleHealthError)
    
    def test_data_validation_error(self):
        """Test DataValidationError exception."""
        error = DataValidationError("Invalid data format")
        assert str(error) == "Invalid data format"
        assert isinstance(error, AppleHealthError)
    
    def test_database_error(self):
        """Test DatabaseError exception."""
        error = DatabaseError("Connection failed")
        assert str(error) == "Connection failed"
        assert isinstance(error, AppleHealthError)
    
    def test_configuration_error(self):
        """Test ConfigurationError exception."""
        error = ConfigurationError("Missing config value")
        assert str(error) == "Missing config value"
        assert isinstance(error, AppleHealthError)
    
    def test_exception_inheritance_chain(self):
        """Test exception inheritance relationships."""
        # All custom exceptions should inherit from AppleHealthError
        assert issubclass(DataImportError, AppleHealthError)
        assert issubclass(DataValidationError, AppleHealthError)
        assert issubclass(DatabaseError, AppleHealthError)
        assert issubclass(ConfigurationError, AppleHealthError)
        
        # AppleHealthError should inherit from Exception
        assert issubclass(AppleHealthError, Exception)


class TestErrorHandlerDecorator:
    """Test error_handler decorator functionality."""
    
    def test_error_handler_basic(self):
        """Test basic error handling with default parameters."""
        @error_handler()
        def test_function():
            raise ValueError("Test error")
        
        result = test_function()
        assert result is None  # Default return value
    
    def test_error_handler_with_custom_return(self):
        """Test error handler with custom default return value."""
        @error_handler(default_return="custom_value")
        def test_function():
            raise ValueError("Test error")
        
        result = test_function()
        assert result == "custom_value"
    
    def test_error_handler_specific_exception(self):
        """Test handling specific exception types."""
        @error_handler(exceptions=ValueError, default_return="caught")
        def test_function(raise_error=True):
            if raise_error:
                raise ValueError("Specific error")
            return "success"
        
        # Should catch ValueError
        assert test_function(raise_error=True) == "caught"
        
        # Should not catch other exceptions
        @error_handler(exceptions=ValueError, default_return="caught")
        def test_function2():
            raise TypeError("Different error")
        
        with pytest.raises(TypeError):
            test_function2()
    
    def test_error_handler_multiple_exceptions(self):
        """Test handling multiple exception types."""
        @error_handler(exceptions=(ValueError, TypeError), default_return="caught")
        def test_function(error_type):
            if error_type == "value":
                raise ValueError("Value error")
            elif error_type == "type":
                raise TypeError("Type error")
            else:
                raise RuntimeError("Runtime error")
        
        assert test_function("value") == "caught"
        assert test_function("type") == "caught"
        
        with pytest.raises(RuntimeError):
            test_function("runtime")
    
    def test_error_handler_reraise(self):
        """Test re-raising exceptions after logging."""
        @error_handler(reraise=True)
        def test_function():
            raise ValueError("Test error")
        
        with pytest.raises(ValueError, match="Test error"):
            test_function()
    
    def test_error_handler_custom_message(self):
        """Test custom error message."""
        with patch('src.utils.error_handler.logger') as mock_logger:
            @error_handler(message="Custom error occurred")
            def test_function():
                raise ValueError("Test error")
            
            test_function()
            
            # Check that custom message was logged
            mock_logger.error.assert_called_once()
            log_message = mock_logger.error.call_args[0][0]
            assert "Custom error occurred" in log_message
    
    def test_error_handler_log_levels(self):
        """Test different log levels."""
        with patch('src.utils.error_handler.logger') as mock_logger:
            # Test ERROR level (default)
            @error_handler(log_level="ERROR")
            def test_error():
                raise ValueError("Error test")
            
            test_error()
            mock_logger.error.assert_called_once()
            
            # Test WARNING level
            @error_handler(log_level="WARNING")
            def test_warning():
                raise ValueError("Warning test")
            
            test_warning()
            mock_logger.warning.assert_called_once()
            
            # Test INFO level
            @error_handler(log_level="INFO")
            def test_info():
                raise ValueError("Info test")
            
            test_info()
            mock_logger.info.assert_called_once()
    
    def test_error_handler_preserves_function_metadata(self):
        """Test that decorator preserves function metadata."""
        @error_handler()
        def test_function(x, y):
            """Test docstring."""
            return x + y
        
        assert test_function.__name__ == "test_function"
        assert test_function.__doc__ == "Test docstring."
        
        # Should work normally when no error
        assert test_function(2, 3) == 5
    
    def test_error_handler_with_args_and_kwargs(self):
        """Test error handler with function arguments."""
        @error_handler(default_return=0)
        def divide(a, b, precision=2):
            return round(a / b, precision)
        
        # Normal operation
        assert divide(10, 2) == 5.0
        assert divide(10, 3, precision=1) == 3.3
        
        # Error case
        assert divide(10, 0) == 0  # Returns default on ZeroDivisionError
    
    def test_error_handler_logging_details(self):
        """Test that error details are properly logged."""
        with patch('src.utils.error_handler.logger') as mock_logger:
            @error_handler()
            def test_function():
                raise ValueError("Detailed error")
            
            test_function()
            
            # Check logged details
            log_call = mock_logger.error.call_args[0][0]
            assert "test_function" in log_call
            assert "ValueError" in log_call
            assert "Detailed error" in log_call
            assert "traceback" in log_call.lower()


class TestSafeFileOperation:
    """Test safe_file_operation decorator."""
    
    def test_safe_file_operation_success(self):
        """Test successful file operation."""
        @safe_file_operation
        def read_file(path):
            return f"Content of {path}"
        
        result = read_file("/test/path.txt")
        assert result == "Content of /test/path.txt"
    
    def test_safe_file_operation_file_not_found(self):
        """Test handling FileNotFoundError."""
        @safe_file_operation
        def read_file(path):
            raise FileNotFoundError(f"No such file: {path}")
        
        with pytest.raises(DataImportError, match="File not found"):
            read_file("/nonexistent.txt")
    
    def test_safe_file_operation_permission_error(self):
        """Test handling PermissionError."""
        @safe_file_operation
        def write_file(path):
            raise PermissionError(f"Cannot write to {path}")
        
        with pytest.raises(DataImportError, match="Permission denied"):
            write_file("/protected.txt")
    
    def test_safe_file_operation_io_error(self):
        """Test handling IOError."""
        @safe_file_operation
        def process_file(path):
            raise IOError("Disk full")
        
        with pytest.raises(DataImportError, match="I/O error"):
            process_file("/test.txt")
    
    def test_safe_file_operation_other_exceptions(self):
        """Test that other exceptions are re-raised."""
        @safe_file_operation
        def process_file(path):
            raise ValueError("Not a file error")
        
        with pytest.raises(ValueError, match="Not a file error"):
            process_file("/test.txt")
    
    def test_safe_file_operation_logging(self):
        """Test that file errors are logged."""
        with patch('src.utils.error_handler.logger') as mock_logger:
            @safe_file_operation
            def read_file(path):
                raise FileNotFoundError("Missing file")
            
            try:
                read_file("/test.txt")
            except DataImportError:
                pass
            
            mock_logger.error.assert_called_once()
            log_message = mock_logger.error.call_args[0][0]
            assert "File not found" in log_message
            assert "read_file" in log_message


class TestSafeDatabaseOperation:
    """Test safe_database_operation decorator."""
    
    def test_safe_database_operation_success(self):
        """Test successful database operation."""
        @safe_database_operation
        def query_db():
            return [{"id": 1, "name": "Test"}]
        
        result = query_db()
        assert result == [{"id": 1, "name": "Test"}]
    
    def test_safe_database_operation_sqlite_error(self):
        """Test handling SQLite errors."""
        # Create a mock SQLite exception
        mock_sqlite_error = type('sqlite3.Error', (Exception,), {
            '__module__': 'sqlite3'
        })("Database locked")
        
        @safe_database_operation
        def query_db():
            raise mock_sqlite_error
        
        with pytest.raises(DatabaseError, match="Database operation failed"):
            query_db()
    
    def test_safe_database_operation_other_exceptions(self):
        """Test that non-database exceptions are re-raised."""
        @safe_database_operation
        def query_db():
            raise ValueError("Not a database error")
        
        with pytest.raises(ValueError, match="Not a database error"):
            query_db()
    
    def test_safe_database_operation_logging(self):
        """Test that database errors are logged."""
        with patch('src.utils.error_handler.logger') as mock_logger:
            mock_sqlite_error = type('sqlite3.Error', (Exception,), {
                '__module__': 'sqlite3'
            })("Connection failed")
            
            @safe_database_operation
            def query_db():
                raise mock_sqlite_error
            
            try:
                query_db()
            except DatabaseError:
                pass
            
            mock_logger.error.assert_called_once()
            log_message = mock_logger.error.call_args[0][0]
            assert "Database error" in log_message
            assert "query_db" in log_message


class TestErrorContext:
    """Test ErrorContext context manager."""
    
    def test_error_context_success(self):
        """Test ErrorContext with successful operation."""
        with patch('src.utils.error_handler.get_logger') as mock_get_logger:
            mock_logger = Mock()
            mock_get_logger.return_value = mock_logger
            
            with ErrorContext("Test operation"):
                result = 1 + 1
            
            assert result == 2
            # No error should be logged
            mock_logger.error.assert_not_called()
    
    def test_error_context_with_error(self):
        """Test ErrorContext with error."""
        with patch('src.utils.error_handler.get_logger') as mock_get_logger:
            mock_logger = Mock()
            mock_get_logger.return_value = mock_logger
            
            with pytest.raises(ValueError):
                with ErrorContext("Test operation", reraise=True):
                    raise ValueError("Test error")
            
            # Error should be logged
            mock_logger.error.assert_called_once()
            log_message = mock_logger.error.call_args[0][0]
            assert "Test operation" in log_message
            assert "ValueError" in log_message
            assert "Test error" in log_message
    
    def test_error_context_no_reraise(self):
        """Test ErrorContext suppressing exceptions."""
        with patch('src.utils.error_handler.get_logger') as mock_get_logger:
            mock_logger = Mock()
            mock_get_logger.return_value = mock_logger
            
            with ErrorContext("Suppressed operation", reraise=False):
                raise ValueError("Suppressed error")
            
            # Should not raise
            mock_logger.error.assert_called_once()
    
    def test_error_context_log_levels(self):
        """Test ErrorContext with different log levels."""
        with patch('src.utils.error_handler.get_logger') as mock_get_logger:
            mock_logger = Mock()
            mock_get_logger.return_value = mock_logger
            
            # Test WARNING level
            with ErrorContext("Warning operation", reraise=False, log_level="WARNING"):
                raise ValueError("Warning error")
            
            mock_logger.warning.assert_called_once()
            
            # Test INFO level
            with ErrorContext("Info operation", reraise=False, log_level="INFO"):
                raise ValueError("Info error")
            
            mock_logger.info.assert_called_once()
    
    def test_error_context_exception_conversion(self):
        """Test ErrorContext converting exceptions to custom types."""
        # Test import error conversion
        with pytest.raises(DataImportError):
            with ErrorContext("Data import operation"):
                raise ValueError("Import failed")
        
        # Test database error conversion
        with pytest.raises(DatabaseError):
            with ErrorContext("Database query operation"):
                raise RuntimeError("Query failed")
        
        # Test validation error conversion
        with pytest.raises(DataValidationError):
            with ErrorContext("Data validation check"):
                raise TypeError("Invalid type")
    
    def test_error_context_preserves_custom_exceptions(self):
        """Test that ErrorContext doesn't re-wrap custom exceptions."""
        with pytest.raises(DataImportError) as exc_info:
            with ErrorContext("Import operation"):
                raise DataImportError("Already custom")
        
        assert str(exc_info.value) == "Already custom"
        assert "Import operation failed" not in str(exc_info.value)
    
    def test_error_context_attributes(self):
        """Test ErrorContext attributes."""
        ctx = ErrorContext("Test", reraise=False, log_level="DEBUG")
        
        assert ctx.operation == "Test"
        assert ctx.reraise is False
        assert ctx.log_level == "DEBUG"
        assert ctx.logger is not None
    
    def test_error_context_traceback_logging(self):
        """Test that ErrorContext logs full traceback."""
        with patch('src.utils.error_handler.get_logger') as mock_get_logger:
            mock_logger = Mock()
            mock_get_logger.return_value = mock_logger
            
            try:
                with ErrorContext("Traceback test"):
                    def nested_function():
                        raise ValueError("Nested error")
                    nested_function()
            except DataValidationError:
                pass
            
            log_call = mock_logger.error.call_args[0][0]
            assert "traceback" in log_call
            assert "nested_function" in log_call


class TestFormatErrorMessage:
    """Test format_error_message function."""
    
    def test_format_error_message_basic(self):
        """Test basic error message formatting."""
        error = ValueError("Test error message")
        message = format_error_message(error)
        
        assert message == "ValueError: Test error message"
    
    def test_format_error_message_with_traceback(self):
        """Test error message with traceback."""
        try:
            raise ValueError("Test error")
        except ValueError as e:
            message = format_error_message(e, include_traceback=True)
            
            assert "ValueError: Test error" in message
            assert "Traceback:" in message
            assert "raise ValueError" in message
    
    def test_format_error_message_custom_exception(self):
        """Test formatting custom exceptions."""
        error = DataImportError("Import failed: invalid format")
        message = format_error_message(error)
        
        assert message == "DataImportError: Import failed: invalid format"
    
    def test_format_error_message_empty_message(self):
        """Test formatting exception with empty message."""
        error = ValueError()
        message = format_error_message(error)
        
        assert message == "ValueError: "
    
    def test_format_error_message_nested_exception(self):
        """Test formatting exception with cause."""
        try:
            try:
                raise ValueError("Original error")
            except ValueError as e:
                raise DataImportError("Wrapped error") from e
        except DataImportError as e:
            message = format_error_message(e, include_traceback=True)
            
            assert "DataImportError: Wrapped error" in message
            assert "Traceback:" in message


class TestIntegration:
    """Integration tests for error handling system."""
    
    def test_decorated_function_chain(self):
        """Test multiple decorators on same function."""
        @error_handler(exceptions=ValueError, default_return=None)
        @safe_file_operation
        def process_file(path):
            if "missing" in path:
                raise FileNotFoundError("File not found")
            elif "invalid" in path:
                raise ValueError("Invalid file")
            return f"Processed {path}"
        
        # Normal operation
        assert process_file("/good/file.txt") == "Processed /good/file.txt"
        
        # File error - converted to DataImportError by safe_file_operation
        with pytest.raises(DataImportError):
            process_file("/missing/file.txt")
        
        # ValueError - caught by error_handler
        assert process_file("/invalid/file.txt") is None
    
    def test_error_context_with_decorators(self):
        """Test ErrorContext with decorated functions."""
        @safe_database_operation
        def query_data():
            mock_sqlite_error = type('sqlite3.Error', (Exception,), {
                '__module__': 'sqlite3'
            })("Query failed")
            raise mock_sqlite_error
        
        with pytest.raises(DatabaseError):
            with ErrorContext("Database operation"):
                query_data()
    
    def test_real_world_scenario(self):
        """Test realistic error handling scenario."""
        class DataProcessor:
            @error_handler(exceptions=(DataImportError, DataValidationError), 
                          default_return=None, 
                          message="Failed to process health data")
            def process_health_data(self, file_path):
                with ErrorContext("Loading health data"):
                    data = self._load_data(file_path)
                
                with ErrorContext("Validating health data"):
                    self._validate_data(data)
                
                return data
            
            @safe_file_operation
            def _load_data(self, file_path):
                if "missing" in file_path:
                    raise FileNotFoundError("Data file not found")
                return {"records": 100}
            
            def _validate_data(self, data):
                if data["records"] < 10:
                    raise DataValidationError("Insufficient records")
        
        processor = DataProcessor()
        
        # Success case
        result = processor.process_health_data("/good/data.xml")
        assert result == {"records": 100}
        
        # File not found - returns None due to error_handler
        result = processor.process_health_data("/missing/data.xml")
        assert result is None
    
    def test_error_logging_consistency(self):
        """Test that all error handling methods log consistently."""
        with patch('src.utils.error_handler.logger') as mock_logger:
            # Test error_handler logging
            @error_handler()
            def test1():
                raise ValueError("Handler error")
            
            test1()
            assert mock_logger.error.called
            
            # Test safe_file_operation logging
            @safe_file_operation
            def test2():
                raise FileNotFoundError("File error")
            
            try:
                test2()
            except DataImportError:
                pass
            assert mock_logger.error.called
            
            # Test ErrorContext logging
            with patch('src.utils.error_handler.get_logger') as mock_get_logger:
                mock_context_logger = Mock()
                mock_get_logger.return_value = mock_context_logger
                
                with ErrorContext("Test", reraise=False):
                    raise ValueError("Context error")
                
                assert mock_context_logger.error.called