"""Comprehensive tests for health score calculation system."""

import pytest
from datetime import date, datetime, timedelta
from unittest.mock import Mock, patch, MagicMock
import pandas as pd
import numpy as np

from src.analytics.health_score import (
    HealthScoreCalculator, ComponentCalculators, TrendAnalyzer,
    PersonalizationEngine, __version__
)
from src.analytics.health_score.health_score_models import (
    HealthScore, ScoreComponent, ScoreCategory, TrendDirection,
    PersonalizationProfile, ScoreHistory, ScoreInsight
)
from src.analytics.health_score.component_calculators import (
    ActivityScoreCalculator, SleepScoreCalculator, HeartHealthCalculator,
    NutritionScoreCalculator, MindfulnessScoreCalculator
)


class TestHealthScoreModels:
    """Test health score model classes."""
    
    def test_score_category_enum(self):
        """Test ScoreCategory enumeration."""
        assert ScoreCategory.ACTIVITY.value == "activity"
        assert ScoreCategory.SLEEP.value == "sleep"
        assert ScoreCategory.HEART_HEALTH.value == "heart_health"
        assert ScoreCategory.NUTRITION.value == "nutrition"
        assert ScoreCategory.MINDFULNESS.value == "mindfulness"
        
    def test_trend_direction_enum(self):
        """Test TrendDirection enumeration."""
        assert TrendDirection.IMPROVING.value == 1
        assert TrendDirection.STABLE.value == 0
        assert TrendDirection.DECLINING.value == -1
        
    def test_health_score_creation(self):
        """Test HealthScore model creation."""
        components = [
            ScoreComponent(
                category=ScoreCategory.ACTIVITY,
                score=85,
                weight=0.3,
                metrics={"steps": 9500, "exercise_minutes": 45}
            ),
            ScoreComponent(
                category=ScoreCategory.SLEEP,
                score=78,
                weight=0.3,
                metrics={"hours": 7.5, "quality": 0.82}
            )
        ]
        
        health_score = HealthScore(
            user_id="user_123",
            date=date.today(),
            overall_score=82,
            components=components,
            trend=TrendDirection.IMPROVING,
            insights=[]
        )
        
        assert health_score.overall_score == 82
        assert len(health_score.components) == 2
        assert health_score.trend == TrendDirection.IMPROVING
        
    def test_score_component_creation(self):
        """Test ScoreComponent creation."""
        component = ScoreComponent(
            category=ScoreCategory.ACTIVITY,
            score=90,
            weight=0.25,
            metrics={
                "steps": 12000,
                "exercise_minutes": 60,
                "active_hours": 8
            },
            sub_scores={
                "steps_score": 95,
                "exercise_score": 85,
                "consistency_score": 90
            }
        )
        
        assert component.score == 90
        assert component.weight == 0.25
        assert component.metrics["steps"] == 12000
        assert component.sub_scores["steps_score"] == 95
        
    def test_personalization_profile(self):
        """Test PersonalizationProfile creation."""
        profile = PersonalizationProfile(
            user_id="user_123",
            age=35,
            gender="male",
            fitness_level="intermediate",
            health_conditions=[],
            goals=["weight_loss", "improve_cardio"],
            preferences={
                "preferred_activities": ["running", "cycling"],
                "sleep_schedule": "early_bird"
            },
            custom_weights={
                ScoreCategory.ACTIVITY: 0.35,
                ScoreCategory.SLEEP: 0.25,
                ScoreCategory.HEART_HEALTH: 0.2,
                ScoreCategory.NUTRITION: 0.15,
                ScoreCategory.MINDFULNESS: 0.05
            }
        )
        
        assert profile.age == 35
        assert "weight_loss" in profile.goals
        assert profile.custom_weights[ScoreCategory.ACTIVITY] == 0.35
        
    def test_score_insight_creation(self):
        """Test ScoreInsight creation."""
        insight = ScoreInsight(
            category=ScoreCategory.SLEEP,
            type="improvement_opportunity",
            message="Your sleep consistency could improve on weekends",
            priority="medium",
            recommendation="Try to maintain similar sleep times on weekends",
            impact_score=15
        )
        
        assert insight.type == "improvement_opportunity"
        assert insight.priority == "medium"
        assert insight.impact_score == 15


class TestComponentCalculators:
    """Test individual component calculators."""
    
    @pytest.fixture
    def activity_data(self):
        """Create sample activity data."""
        dates = pd.date_range(start='2023-01-01', periods=30, freq='D')
        data = {
            'steps': np.random.randint(5000, 12000, 30),
            'exercise_minutes': np.random.randint(0, 60, 30),
            'active_hours': np.random.randint(4, 10, 30),
            'calories_burned': np.random.randint(1800, 2500, 30)
        }
        return pd.DataFrame(data, index=dates)
    
    @pytest.fixture
    def sleep_data(self):
        """Create sample sleep data."""
        dates = pd.date_range(start='2023-01-01', periods=30, freq='D')
        data = {
            'sleep_hours': np.random.normal(7.5, 0.5, 30),
            'deep_sleep_hours': np.random.normal(1.5, 0.3, 30),
            'rem_sleep_hours': np.random.normal(1.8, 0.4, 30),
            'sleep_quality': np.random.uniform(0.7, 0.95, 30)
        }
        return pd.DataFrame(data, index=dates)
    
    def test_activity_score_calculator(self, activity_data):
        """Test activity score calculation."""
        calculator = ActivityScoreCalculator()
        
        # Calculate score for a single day
        day_data = activity_data.iloc[0]
        score = calculator.calculate_score(
            steps=day_data['steps'],
            exercise_minutes=day_data['exercise_minutes'],
            active_hours=day_data['active_hours']
        )
        
        assert 0 <= score <= 100
        
        # Test with perfect values
        perfect_score = calculator.calculate_score(
            steps=10000,
            exercise_minutes=30,
            active_hours=8
        )
        assert perfect_score >= 90
        
        # Test with poor values
        poor_score = calculator.calculate_score(
            steps=2000,
            exercise_minutes=0,
            active_hours=2
        )
        assert poor_score < 50
        
    def test_sleep_score_calculator(self, sleep_data):
        """Test sleep score calculation."""
        calculator = SleepScoreCalculator()
        
        # Calculate score for a single night
        night_data = sleep_data.iloc[0]
        score = calculator.calculate_score(
            hours=night_data['sleep_hours'],
            deep_sleep_ratio=night_data['deep_sleep_hours'] / night_data['sleep_hours'],
            rem_sleep_ratio=night_data['rem_sleep_hours'] / night_data['sleep_hours'],
            quality=night_data['sleep_quality']
        )
        
        assert 0 <= score <= 100
        
        # Test with optimal values
        optimal_score = calculator.calculate_score(
            hours=8,
            deep_sleep_ratio=0.2,
            rem_sleep_ratio=0.25,
            quality=0.95
        )
        assert optimal_score >= 90
        
    def test_heart_health_calculator(self):
        """Test heart health score calculation."""
        calculator = HeartHealthCalculator()
        
        # Test with healthy values
        healthy_score = calculator.calculate_score(
            resting_heart_rate=60,
            heart_rate_variability=50,
            blood_pressure_systolic=120,
            blood_pressure_diastolic=80
        )
        assert healthy_score >= 80
        
        # Test with concerning values
        poor_score = calculator.calculate_score(
            resting_heart_rate=90,
            heart_rate_variability=20,
            blood_pressure_systolic=140,
            blood_pressure_diastolic=95
        )
        assert poor_score < 60
        
    def test_nutrition_score_calculator(self):
        """Test nutrition score calculation."""
        calculator = NutritionScoreCalculator()
        
        # Test with balanced nutrition
        balanced_score = calculator.calculate_score(
            calories_consumed=2000,
            calories_target=2000,
            protein_grams=60,
            carbs_grams=250,
            fat_grams=70,
            fiber_grams=30,
            water_liters=2.5
        )
        assert balanced_score >= 80
        
        # Test with poor nutrition
        poor_score = calculator.calculate_score(
            calories_consumed=3500,
            calories_target=2000,
            protein_grams=30,
            carbs_grams=400,
            fat_grams=150,
            fiber_grams=10,
            water_liters=1.0
        )
        assert poor_score < 60
        
    def test_mindfulness_score_calculator(self):
        """Test mindfulness score calculation."""
        calculator = MindfulnessScoreCalculator()
        
        # Test with good mindfulness practice
        good_score = calculator.calculate_score(
            meditation_minutes=20,
            stress_level=3,  # 1-10 scale
            mood_rating=8,   # 1-10 scale
            mindful_activities=3
        )
        assert good_score >= 80
        
        # Test with poor mindfulness
        poor_score = calculator.calculate_score(
            meditation_minutes=0,
            stress_level=8,
            mood_rating=3,
            mindful_activities=0
        )
        assert poor_score < 50


class TestHealthScoreCalculator:
    """Test the main health score calculator."""
    
    @pytest.fixture
    def calculator(self):
        """Create health score calculator."""
        return HealthScoreCalculator()
    
    @pytest.fixture
    def comprehensive_health_data(self):
        """Create comprehensive health data."""
        dates = pd.date_range(start='2023-01-01', periods=30, freq='D')
        
        data = {
            # Activity data
            'steps': np.random.randint(6000, 11000, 30),
            'exercise_minutes': np.random.randint(15, 45, 30),
            'active_hours': np.random.randint(5, 9, 30),
            
            # Sleep data
            'sleep_hours': np.random.normal(7.5, 0.5, 30),
            'sleep_quality': np.random.uniform(0.75, 0.90, 30),
            
            # Heart health data
            'resting_heart_rate': np.random.randint(58, 68, 30),
            'heart_rate_variability': np.random.randint(35, 55, 30),
            
            # Nutrition data (simplified)
            'calories': np.random.randint(1800, 2200, 30),
            'water_liters': np.random.uniform(1.5, 3.0, 30),
            
            # Mindfulness data
            'meditation_minutes': np.random.randint(0, 20, 30),
            'stress_level': np.random.randint(3, 6, 30)
        }
        
        return pd.DataFrame(data, index=dates)
    
    def test_calculate_daily_score(self, calculator, comprehensive_health_data):
        """Test daily health score calculation."""
        day_data = comprehensive_health_data.iloc[0]
        
        score = calculator.calculate_daily_score(
            user_id="test_user",
            date=comprehensive_health_data.index[0].date(),
            health_data=day_data.to_dict()
        )
        
        assert isinstance(score, HealthScore)
        assert 0 <= score.overall_score <= 100
        assert len(score.components) > 0
        assert sum(c.weight for c in score.components) == pytest.approx(1.0)
        
    def test_calculate_period_scores(self, calculator, comprehensive_health_data):
        """Test period health score calculation."""
        scores = calculator.calculate_period_scores(
            user_id="test_user",
            start_date=date(2023, 1, 1),
            end_date=date(2023, 1, 30),
            health_data=comprehensive_health_data
        )
        
        assert len(scores) == 30
        assert all(isinstance(s, HealthScore) for s in scores)
        assert all(0 <= s.overall_score <= 100 for s in scores)
        
    def test_weighted_scoring(self, calculator):
        """Test that component weights affect overall score."""
        # Create two scenarios with same sub-scores but different weights
        components1 = [
            ScoreComponent(ScoreCategory.ACTIVITY, 90, 0.5, {}),
            ScoreComponent(ScoreCategory.SLEEP, 70, 0.5, {})
        ]
        
        components2 = [
            ScoreComponent(ScoreCategory.ACTIVITY, 90, 0.2, {}),
            ScoreComponent(ScoreCategory.SLEEP, 70, 0.8, {})
        ]
        
        score1 = calculator._calculate_weighted_score(components1)
        score2 = calculator._calculate_weighted_score(components2)
        
        assert score1 == 80  # (90*0.5 + 70*0.5)
        assert score2 == 74  # (90*0.2 + 70*0.8)
        
    def test_missing_data_handling(self, calculator):
        """Test handling of missing data."""
        incomplete_data = {
            'steps': 8000,
            'sleep_hours': 7.5
            # Missing other metrics
        }
        
        score = calculator.calculate_daily_score(
            user_id="test_user",
            date=date.today(),
            health_data=incomplete_data
        )
        
        # Should still calculate score with available data
        assert score is not None
        assert score.overall_score > 0
        # Should only have components for available data
        categories = [c.category for c in score.components]
        assert ScoreCategory.ACTIVITY in categories
        assert ScoreCategory.SLEEP in categories
        assert ScoreCategory.HEART_HEALTH not in categories


class TestTrendAnalyzer:
    """Test trend analysis functionality."""
    
    @pytest.fixture
    def analyzer(self):
        """Create trend analyzer."""
        return TrendAnalyzer()
    
    @pytest.fixture
    def score_history(self):
        """Create score history."""
        dates = pd.date_range(start='2023-01-01', periods=30, freq='D')
        scores = []
        
        # Create improving trend
        for i, d in enumerate(dates):
            base_score = 70 + (i * 0.5)  # Gradual improvement
            daily_score = base_score + np.random.normal(0, 2)
            
            scores.append(HealthScore(
                user_id="test_user",
                date=d.date(),
                overall_score=min(100, max(0, daily_score)),
                components=[],
                trend=TrendDirection.STABLE,
                insights=[]
            ))
            
        return scores
    
    def test_analyze_trend_improving(self, analyzer, score_history):
        """Test detection of improving trend."""
        trend = analyzer.analyze_trend(score_history)
        
        assert trend.direction == TrendDirection.IMPROVING
        assert trend.change_rate > 0
        assert trend.confidence > 0.7
        
    def test_analyze_trend_declining(self, analyzer):
        """Test detection of declining trend."""
        dates = pd.date_range(start='2023-01-01', periods=20, freq='D')
        scores = []
        
        # Create declining trend
        for i, d in enumerate(dates):
            base_score = 85 - (i * 0.8)
            daily_score = base_score + np.random.normal(0, 1)
            
            scores.append(HealthScore(
                user_id="test_user",
                date=d.date(),
                overall_score=min(100, max(0, daily_score)),
                components=[],
                trend=TrendDirection.STABLE,
                insights=[]
            ))
        
        trend = analyzer.analyze_trend(scores)
        
        assert trend.direction == TrendDirection.DECLINING
        assert trend.change_rate < 0
        
    def test_analyze_trend_stable(self, analyzer):
        """Test detection of stable trend."""
        dates = pd.date_range(start='2023-01-01', periods=20, freq='D')
        scores = []
        
        # Create stable trend with small fluctuations
        for d in dates:
            daily_score = 75 + np.random.normal(0, 2)
            
            scores.append(HealthScore(
                user_id="test_user",
                date=d.date(),
                overall_score=min(100, max(0, daily_score)),
                components=[],
                trend=TrendDirection.STABLE,
                insights=[]
            ))
        
        trend = analyzer.analyze_trend(scores)
        
        assert trend.direction == TrendDirection.STABLE
        assert abs(trend.change_rate) < 0.1
        
    def test_component_trends(self, analyzer):
        """Test component-level trend analysis."""
        dates = pd.date_range(start='2023-01-01', periods=20, freq='D')
        scores = []
        
        for i, d in enumerate(dates):
            # Activity improving, sleep declining
            activity_score = 70 + i
            sleep_score = 85 - i
            
            components = [
                ScoreComponent(ScoreCategory.ACTIVITY, activity_score, 0.5, {}),
                ScoreComponent(ScoreCategory.SLEEP, sleep_score, 0.5, {})
            ]
            
            scores.append(HealthScore(
                user_id="test_user",
                date=d.date(),
                overall_score=(activity_score + sleep_score) / 2,
                components=components,
                trend=TrendDirection.STABLE,
                insights=[]
            ))
        
        component_trends = analyzer.analyze_component_trends(scores)
        
        assert component_trends[ScoreCategory.ACTIVITY] == TrendDirection.IMPROVING
        assert component_trends[ScoreCategory.SLEEP] == TrendDirection.DECLINING
        
    def test_insufficient_data(self, analyzer):
        """Test handling of insufficient data for trend analysis."""
        # Only 3 days of data
        short_history = [
            HealthScore(
                user_id="test_user",
                date=date.today() - timedelta(days=i),
                overall_score=75,
                components=[],
                trend=TrendDirection.STABLE,
                insights=[]
            )
            for i in range(3)
        ]
        
        trend = analyzer.analyze_trend(short_history)
        
        # Should return stable with low confidence
        assert trend.direction == TrendDirection.STABLE
        assert trend.confidence < 0.5


class TestPersonalizationEngine:
    """Test personalization functionality."""
    
    @pytest.fixture
    def engine(self):
        """Create personalization engine."""
        return PersonalizationEngine()
    
    @pytest.fixture
    def user_profile(self):
        """Create user profile."""
        return PersonalizationProfile(
            user_id="test_user",
            age=35,
            gender="female",
            fitness_level="beginner",
            health_conditions=["hypertension"],
            goals=["improve_cardio", "reduce_stress"],
            preferences={
                "preferred_activities": ["walking", "yoga"],
                "sleep_schedule": "night_owl"
            }
        )
    
    def test_personalize_weights(self, engine, user_profile):
        """Test weight personalization based on profile."""
        weights = engine.personalize_weights(user_profile)
        
        # Should emphasize heart health due to hypertension
        assert weights[ScoreCategory.HEART_HEALTH] > 0.2
        
        # Should emphasize mindfulness due to stress reduction goal
        assert weights[ScoreCategory.MINDFULNESS] > 0.1
        
        # Weights should sum to 1
        assert sum(weights.values()) == pytest.approx(1.0)
        
    def test_personalize_targets(self, engine, user_profile):
        """Test target personalization."""
        targets = engine.personalize_targets(user_profile)
        
        # Beginner should have achievable targets
        assert targets['daily_steps'] <= 8000
        assert targets['exercise_minutes'] <= 30
        
        # Should include stress-reduction targets
        assert 'meditation_minutes' in targets
        assert targets['meditation_minutes'] > 0
        
    def test_generate_personalized_insights(self, engine, user_profile):
        """Test personalized insight generation."""
        score = HealthScore(
            user_id="test_user",
            date=date.today(),
            overall_score=72,
            components=[
                ScoreComponent(
                    ScoreCategory.ACTIVITY,
                    score=65,
                    weight=0.3,
                    metrics={"steps": 5000}
                ),
                ScoreComponent(
                    ScoreCategory.MINDFULNESS,
                    score=50,
                    weight=0.2,
                    metrics={"meditation_minutes": 5}
                )
            ],
            trend=TrendDirection.STABLE,
            insights=[]
        )
        
        insights = engine.generate_personalized_insights(score, user_profile)
        
        assert len(insights) > 0
        
        # Should include activity insight for beginner
        activity_insight = next((i for i in insights if i.category == ScoreCategory.ACTIVITY), None)
        assert activity_insight is not None
        assert "walking" in activity_insight.recommendation.lower() or "steps" in activity_insight.recommendation.lower()
        
        # Should include stress-reduction insight
        mindfulness_insight = next((i for i in insights if i.category == ScoreCategory.MINDFULNESS), None)
        assert mindfulness_insight is not None
        
    def test_adaptive_learning(self, engine, user_profile):
        """Test adaptive learning from user data."""
        # Simulate user consistently exceeding targets
        performance_data = {
            'average_steps': 9000,
            'average_exercise_minutes': 35,
            'consistency_rate': 0.85
        }
        
        updated_profile = engine.update_profile_from_performance(
            user_profile,
            performance_data
        )
        
        # Should upgrade fitness level
        assert updated_profile.fitness_level != "beginner"
        
        # Should adjust targets upward
        new_targets = engine.personalize_targets(updated_profile)
        old_targets = engine.personalize_targets(user_profile)
        
        assert new_targets['daily_steps'] > old_targets['daily_steps']


def test_health_score_integration():
    """Test integration of health score components."""
    # Create calculator
    calculator = HealthScoreCalculator()
    
    # Create comprehensive health data for a week
    dates = pd.date_range(start='2023-01-01', periods=7, freq='D')
    health_data = pd.DataFrame({
        'steps': [8000, 9500, 7000, 10500, 8500, 12000, 6000],
        'exercise_minutes': [30, 45, 20, 60, 35, 50, 15],
        'sleep_hours': [7.5, 8, 6.5, 7.8, 7.2, 8.5, 6],
        'resting_heart_rate': [62, 60, 64, 58, 61, 59, 65],
        'stress_level': [4, 3, 5, 3, 4, 2, 6],
        'meditation_minutes': [10, 15, 5, 20, 10, 25, 0]
    }, index=dates)
    
    # Calculate scores for the week
    scores = calculator.calculate_period_scores(
        user_id="test_user",
        start_date=dates[0].date(),
        end_date=dates[-1].date(),
        health_data=health_data
    )
    
    assert len(scores) == 7
    
    # Analyze trends
    analyzer = TrendAnalyzer()
    trend = analyzer.analyze_trend(scores)
    
    # Check that high activity days have higher scores
    high_activity_indices = [3, 5]  # Days with 10500 and 12000 steps
    for idx in high_activity_indices:
        assert scores[idx].overall_score > 75
    
    # Test personalization
    profile = PersonalizationProfile(
        user_id="test_user",
        age=40,
        gender="male",
        fitness_level="intermediate",
        health_conditions=[],
        goals=["maintain_fitness"],
        preferences={}
    )
    
    engine = PersonalizationEngine()
    
    # Generate personalized insights for the last day
    insights = engine.generate_personalized_insights(scores[-1], profile)
    
    # Should identify the low activity on the last day
    assert len(insights) > 0
    assert any(i.category == ScoreCategory.ACTIVITY for i in insights)
    
    # Test score history storage and retrieval
    history = ScoreHistory(
        user_id="test_user",
        scores=scores,
        period_start=dates[0].date(),
        period_end=dates[-1].date()
    )
    
    # Calculate weekly average
    weekly_average = sum(s.overall_score for s in scores) / len(scores)
    assert 60 <= weekly_average <= 85  # Reasonable range
    
    # Verify component consistency
    for score in scores:
        # All scores should have the same component categories
        categories = {c.category for c in score.components}
        assert ScoreCategory.ACTIVITY in categories
        assert ScoreCategory.SLEEP in categories