"""Comprehensive tests for main window UI component."""

import pytest
from datetime import date, datetime, timedelta
from unittest.mock import Mock, patch, MagicMock, PropertyMock
import pandas as pd
import numpy as np
from PyQt6.QtWidgets import QApplication, QMainWindow, QMessageBox
from PyQt6.QtCore import Qt, QDate, QTimer
from PyQt6.QtTest import QTest

from src.ui.main_window import MainWindow


class TestMainWindow:
    """Test main window functionality."""
    
    @pytest.fixture
    def app(self, qapp):
        """Get Qt application."""
        return qapp
    
    @pytest.fixture
    def main_window(self, qtbot):
        """Create main window instance."""
        window = MainWindow()
        qtbot.addWidget(window)
        return window
    
    @pytest.fixture
    def mock_data(self):
        """Create mock health data."""
        dates = pd.date_range('2023-01-01', periods=30, freq='D')
        data = pd.DataFrame({
            'date': dates,
            'steps': np.random.randint(5000, 15000, size=30),
            'heart_rate': np.random.randint(60, 80, size=30),
            'sleep_hours': np.random.uniform(6, 9, size=30)
        })
        return data
    
    def test_initialization(self, main_window):
        """Test main window initialization."""
        assert isinstance(main_window, QMainWindow)
        assert main_window.windowTitle() == "Apple Health Monitor"
        
        # Check main components exist
        assert hasattr(main_window, 'central_widget')
        assert hasattr(main_window, 'config_tab')
        assert hasattr(main_window, 'tab_widget')
        
    def test_menu_bar_creation(self, main_window):
        """Test menu bar creation."""
        menu_bar = main_window.menuBar()
        assert menu_bar is not None
        
        # Check menus exist
        menus = [action.text() for action in menu_bar.actions()]
        assert any('File' in menu for menu in menus)
        assert any('View' in menu for menu in menus)
        assert any('Help' in menu for menu in menus)
        
    def test_status_bar(self, main_window):
        """Test status bar functionality."""
        status_bar = main_window.statusBar()
        assert status_bar is not None
        
        # Test status message
        main_window.show_status_message("Test message", 2000)
        assert status_bar.currentMessage() == "Test message"
        
    def test_tab_widget(self, main_window):
        """Test tab widget functionality."""
        tab_widget = main_window.tab_widget
        assert tab_widget is not None
        
        # Check default tabs
        assert tab_widget.count() > 0
        
        # Configuration tab should be first
        assert tab_widget.tabText(0) == "Configuration"
        
    @patch('src.ui.main_window.DataLoader')
    def test_data_loading(self, mock_loader, main_window, mock_data, qtbot):
        """Test data loading functionality."""
        # Setup mock
        mock_loader_instance = Mock()
        mock_loader_instance.load_data.return_value = mock_data
        mock_loader_instance.get_available_metrics.return_value = ['steps', 'heart_rate', 'sleep_hours']
        mock_loader.return_value = mock_loader_instance
        
        # Trigger data load
        main_window.load_data()
        
        # Wait for async operations
        qtbot.wait(100)
        
        # Verify data was loaded
        assert main_window.current_data is not None
        assert len(main_window.current_data) == 30
        
    def test_metric_selection(self, main_window, qtbot):
        """Test metric selection functionality."""
        # Mock configuration tab
        main_window.config_tab.get_selected_metrics = Mock(return_value=['steps', 'heart_rate'])
        
        # Test metric selection
        selected = main_window.get_selected_metrics()
        assert 'steps' in selected
        assert 'heart_rate' in selected
        assert len(selected) == 2
        
    def test_date_range_selection(self, main_window, qtbot):
        """Test date range selection."""
        # Set date range
        start_date = QDate(2023, 1, 1)
        end_date = QDate(2023, 1, 31)
        
        main_window.config_tab.start_date = Mock()
        main_window.config_tab.start_date.date.return_value = start_date
        main_window.config_tab.end_date = Mock()
        main_window.config_tab.end_date.date.return_value = end_date
        
        # Get selected range
        date_range = main_window.get_selected_date_range()
        assert date_range['start'] == date(2023, 1, 1)
        assert date_range['end'] == date(2023, 1, 31)
        
    def test_view_mode_switching(self, main_window, qtbot):
        """Test switching between view modes."""
        # Test daily view
        main_window.switch_to_daily_view()
        assert main_window.current_view_mode == 'daily'
        
        # Test weekly view
        main_window.switch_to_weekly_view()
        assert main_window.current_view_mode == 'weekly'
        
        # Test monthly view
        main_window.switch_to_monthly_view()
        assert main_window.current_view_mode == 'monthly'
        
    @patch('src.ui.main_window.QFileDialog')
    def test_import_functionality(self, mock_dialog, main_window, qtbot):
        """Test data import functionality."""
        # Mock file dialog
        mock_dialog.getOpenFileName.return_value = ('/path/to/export.xml', 'XML Files (*.xml)')
        
        # Mock import process
        with patch.object(main_window, 'import_worker') as mock_worker:
            main_window.import_data()
            
            # Verify import was triggered
            mock_dialog.getOpenFileName.assert_called_once()
            
    @patch('src.ui.main_window.QFileDialog')
    def test_export_functionality(self, mock_dialog, main_window, mock_data, qtbot):
        """Test data export functionality."""
        # Set current data
        main_window.current_data = mock_data
        
        # Mock file dialog
        mock_dialog.getSaveFileName.return_value = ('/path/to/export.csv', 'CSV Files (*.csv)')
        
        # Test export
        with patch('pandas.DataFrame.to_csv') as mock_to_csv:
            main_window.export_data()
            
            mock_dialog.getSaveFileName.assert_called_once()
            mock_to_csv.assert_called_once()
            
    def test_refresh_functionality(self, main_window, qtbot):
        """Test data refresh functionality."""
        # Mock data loading
        main_window.load_data = Mock()
        
        # Trigger refresh
        main_window.refresh_data()
        
        # Verify load was called
        main_window.load_data.assert_called_once()
        
    def test_keyboard_shortcuts(self, main_window, qtbot):
        """Test keyboard shortcuts."""
        # Test Ctrl+O (Open/Import)
        QTest.keyClick(main_window, Qt.Key.Key_O, Qt.KeyboardModifier.ControlModifier)
        
        # Test Ctrl+S (Save/Export)
        QTest.keyClick(main_window, Qt.Key.Key_S, Qt.KeyboardModifier.ControlModifier)
        
        # Test F5 (Refresh)
        QTest.keyClick(main_window, Qt.Key.Key_F5)
        
    def test_error_handling(self, main_window, qtbot):
        """Test error handling in main window."""
        # Mock error during data load
        with patch.object(main_window, 'data_loader') as mock_loader:
            mock_loader.load_data.side_effect = Exception("Test error")
            
            # Should handle error gracefully
            with patch.object(QMessageBox, 'critical') as mock_msg:
                main_window.load_data()
                
                # Error message should be shown
                mock_msg.assert_called_once()
                
    def test_window_state_persistence(self, main_window, qtbot):
        """Test window state saving/restoring."""
        # Set window size and position
        main_window.resize(1200, 800)
        main_window.move(100, 100)
        
        # Save state
        main_window.save_window_state()
        
        # Create new window
        new_window = MainWindow()
        qtbot.addWidget(new_window)
        
        # State should be restored
        assert new_window.width() == 1200
        assert new_window.height() == 800
        
    def test_responsive_layout(self, main_window, qtbot):
        """Test responsive layout behavior."""
        # Test small window
        main_window.resize(800, 600)
        qtbot.wait(100)
        
        # Components should adapt
        assert main_window.width() == 800
        
        # Test large window
        main_window.resize(1600, 1200)
        qtbot.wait(100)
        
        assert main_window.width() == 1600
        
    def test_theme_switching(self, main_window, qtbot):
        """Test theme switching functionality."""
        # Test light theme
        main_window.set_theme('light')
        assert main_window.current_theme == 'light'
        
        # Test dark theme
        main_window.set_theme('dark')
        assert main_window.current_theme == 'dark'
        
    def test_progress_indication(self, main_window, qtbot):
        """Test progress indication during long operations."""
        # Start progress
        main_window.show_progress("Loading data...", 0, 100)
        assert main_window.progress_dialog is not None
        assert main_window.progress_dialog.isVisible()
        
        # Update progress
        main_window.update_progress(50)
        assert main_window.progress_dialog.value() == 50
        
        # Complete progress
        main_window.hide_progress()
        assert not main_window.progress_dialog.isVisible()
        
    def test_tab_management(self, main_window, qtbot):
        """Test dynamic tab management."""
        initial_count = main_window.tab_widget.count()
        
        # Add custom tab
        from PyQt6.QtWidgets import QWidget
        custom_widget = QWidget()
        main_window.add_tab(custom_widget, "Custom Tab")
        
        assert main_window.tab_widget.count() == initial_count + 1
        assert main_window.tab_widget.tabText(initial_count) == "Custom Tab"
        
        # Remove tab
        main_window.remove_tab(initial_count)
        assert main_window.tab_widget.count() == initial_count
        
    def test_real_time_updates(self, main_window, qtbot):
        """Test real-time data updates."""
        # Mock timer for updates
        main_window.update_timer = QTimer()
        main_window.update_timer.timeout.connect(main_window.update_data)
        
        # Mock update function
        main_window.update_data = Mock()
        
        # Start timer
        main_window.start_real_time_updates(1000)  # 1 second interval
        
        # Wait for timer
        qtbot.wait(1500)
        
        # Update should have been called
        main_window.update_data.assert_called()
        
        # Stop timer
        main_window.stop_real_time_updates()
        
    def test_multi_window_support(self, main_window, qtbot):
        """Test multiple window instances."""
        # Create second window
        window2 = MainWindow()
        qtbot.addWidget(window2)
        
        # Both windows should be independent
        main_window.setWindowTitle("Window 1")
        window2.setWindowTitle("Window 2")
        
        assert main_window.windowTitle() == "Window 1"
        assert window2.windowTitle() == "Window 2"
        
    def test_accessibility(self, main_window):
        """Test accessibility features."""
        # Check tab order
        assert main_window.focusPolicy() != Qt.FocusPolicy.NoFocus
        
        # Check accessible descriptions
        main_window.setAccessibleName("Main Application Window")
        assert main_window.accessibleName() == "Main Application Window"
        
        # Check tooltips
        main_window.setToolTip("Apple Health Monitor Application")
        assert main_window.toolTip() == "Apple Health Monitor Application"


class TestMainWindowIntegration:
    """Integration tests for main window."""
    
    @pytest.fixture
    def integrated_window(self, qtbot):
        """Create fully integrated main window."""
        with patch('src.ui.main_window.DataLoader'):
            window = MainWindow()
            qtbot.addWidget(window)
            window.show()
            return window
            
    def test_full_workflow(self, integrated_window, qtbot):
        """Test complete user workflow."""
        # 1. Select metrics
        integrated_window.config_tab.metric_selector = Mock()
        integrated_window.config_tab.metric_selector.get_selected_items.return_value = ['steps']
        
        # 2. Set date range
        integrated_window.config_tab.start_date = Mock()
        integrated_window.config_tab.start_date.date.return_value = QDate(2023, 1, 1)
        integrated_window.config_tab.end_date = Mock()
        integrated_window.config_tab.end_date.date.return_value = QDate(2023, 1, 31)
        
        # 3. Load data
        with patch.object(integrated_window, 'data_loader') as mock_loader:
            mock_data = pd.DataFrame({
                'date': pd.date_range('2023-01-01', periods=31),
                'steps': np.random.randint(5000, 15000, size=31)
            })
            mock_loader.load_data.return_value = mock_data
            
            integrated_window.load_data()
            qtbot.wait(100)
            
        # 4. Verify visualization tabs were created
        assert integrated_window.tab_widget.count() > 1
        
    def test_error_recovery(self, integrated_window, qtbot):
        """Test error recovery in integrated scenario."""
        # Simulate database error
        with patch.object(integrated_window, 'data_loader') as mock_loader:
            mock_loader.load_data.side_effect = Exception("Database error")
            
            # Should show error and remain functional
            with patch.object(QMessageBox, 'critical'):
                integrated_window.load_data()
                
        # Window should still be responsive
        assert integrated_window.isVisible()
        assert integrated_window.isEnabled()


def test_main_window_performance(qtbot, qapp):
    """Test main window performance with large datasets."""
    window = MainWindow()
    qtbot.addWidget(window)
    
    # Create large dataset
    large_data = pd.DataFrame({
        'date': pd.date_range('2020-01-01', periods=1000),
        'steps': np.random.randint(5000, 15000, size=1000),
        'heart_rate': np.random.randint(60, 80, size=1000)
    })
    
    # Mock data loader
    with patch.object(window, 'data_loader') as mock_loader:
        mock_loader.load_data.return_value = large_data
        
        # Measure load time
        import time
        start = time.time()
        window.load_data()
        qtbot.wait(100)
        elapsed = time.time() - start
        
        # Should complete reasonably fast
        assert elapsed < 5.0  # 5 seconds max