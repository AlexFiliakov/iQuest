"""
Comprehensive test suite for Data Access Objects with high coverage.
Tests all DAOs including JournalDAO, PreferenceDAO, RecentFilesDAO, CacheDAO, etc.
"""

import pytest
from datetime import date, datetime, timedelta
from unittest.mock import Mock, patch, MagicMock
import json
import hashlib

from src.data_access import (
    JournalDAO, PreferenceDAO, RecentFilesDAO, CacheDAO,
    MetricsMetadataDAO, DataSourceDAO, ImportHistoryDAO
)
from src.models import JournalEntry, UserPreference, RecentFile
from src.database import DatabaseManager


class TestJournalDAO:
    """Test JournalDAO functionality."""
    
    @patch('src.data_access.DatabaseManager')
    def test_save_journal_entry_new(self, mock_db_manager):
        """Test saving a new journal entry."""
        mock_db = Mock()
        mock_db.execute_command.return_value = 1
        mock_db_manager.return_value = mock_db
        
        entry_id = JournalDAO.save_journal_entry(
            entry_date=date(2024, 1, 15),
            entry_type='daily',
            content='Today I walked 10,000 steps!'
        )
        
        assert entry_id == 1
        mock_db.execute_command.assert_called_once()
        
        # Check the SQL query
        call_args = mock_db.execute_command.call_args
        query = call_args[0][0]
        params = call_args[0][1]
        
        assert "INSERT INTO journal_entries" in query
        assert "ON CONFLICT(entry_date, entry_type)" in query
        assert params[0] == '2024-01-15'
        assert params[1] == 'daily'
        assert params[4] == 'Today I walked 10,000 steps!'
    
    @patch('src.data_access.DatabaseManager')
    def test_save_journal_entry_weekly(self, mock_db_manager):
        """Test saving a weekly journal entry."""
        mock_db = Mock()
        mock_db.execute_command.return_value = 2
        mock_db_manager.return_value = mock_db
        
        entry_id = JournalDAO.save_journal_entry(
            entry_date=date(2024, 1, 21),
            entry_type='weekly',
            content='Great week of fitness!',
            week_start_date=date(2024, 1, 15)
        )
        
        assert entry_id == 2
        call_args = mock_db.execute_command.call_args
        params = call_args[0][1]
        assert params[2] == '2024-01-15'  # week_start_date
    
    @patch('src.data_access.DatabaseManager')
    def test_save_journal_entry_monthly(self, mock_db_manager):
        """Test saving a monthly journal entry."""
        mock_db = Mock()
        mock_db.execute_command.return_value = 3
        mock_db_manager.return_value = mock_db
        
        entry_id = JournalDAO.save_journal_entry(
            entry_date=date(2024, 1, 31),
            entry_type='monthly',
            content='January summary',
            month_year='2024-01'
        )
        
        assert entry_id == 3
        call_args = mock_db.execute_command.call_args
        params = call_args[0][1]
        assert params[3] == '2024-01'  # month_year
    
    @patch('src.data_access.DatabaseManager')
    def test_save_journal_entry_error(self, mock_db_manager):
        """Test error handling when saving journal entry."""
        mock_db = Mock()
        mock_db.execute_command.side_effect = Exception("Database error")
        mock_db_manager.return_value = mock_db
        
        with pytest.raises(Exception, match="Database error"):
            JournalDAO.save_journal_entry(
                entry_date=date(2024, 1, 15),
                entry_type='daily',
                content='Test'
            )
    
    @patch('src.data_access.DatabaseManager')
    def test_get_journal_entries(self, mock_db_manager):
        """Test retrieving journal entries."""
        mock_db = Mock()
        mock_results = [
            {
                'id': 1,
                'entry_date': '2024-01-15',
                'entry_type': 'daily',
                'content': 'Day 1',
                'week_start_date': None,
                'month_year': None,
                'created_at': '2024-01-15T10:00:00',
                'updated_at': '2024-01-15T10:00:00'
            },
            {
                'id': 2,
                'entry_date': '2024-01-16',
                'entry_type': 'daily',
                'content': 'Day 2',
                'week_start_date': None,
                'month_year': None,
                'created_at': '2024-01-16T10:00:00',
                'updated_at': '2024-01-16T10:00:00'
            }
        ]
        mock_db.execute_query.return_value = mock_results
        mock_db_manager.return_value = mock_db
        
        entries = JournalDAO.get_journal_entries(
            start_date=date(2024, 1, 15),
            end_date=date(2024, 1, 31)
        )
        
        assert len(entries) == 2
        assert isinstance(entries[0], JournalEntry)
        assert entries[0].content == 'Day 1'
        
        # Check query parameters
        call_args = mock_db.execute_query.call_args
        params = call_args[0][1]
        assert params[0] == '2024-01-15'
        assert params[1] == '2024-01-31'
    
    @patch('src.data_access.DatabaseManager')
    def test_get_journal_entries_with_type_filter(self, mock_db_manager):
        """Test retrieving journal entries with type filter."""
        mock_db = Mock()
        mock_db.execute_query.return_value = []
        mock_db_manager.return_value = mock_db
        
        JournalDAO.get_journal_entries(
            start_date=date(2024, 1, 1),
            end_date=date(2024, 1, 31),
            entry_type='weekly'
        )
        
        call_args = mock_db.execute_query.call_args
        query = call_args[0][0]
        params = call_args[0][1]
        
        assert "AND entry_type = ?" in query
        assert params[2] == 'weekly'
    
    @patch('src.data_access.DatabaseManager')
    def test_get_journal_entries_error(self, mock_db_manager):
        """Test error handling when retrieving entries."""
        mock_db = Mock()
        mock_db.execute_query.side_effect = Exception("Query error")
        mock_db_manager.return_value = mock_db
        
        entries = JournalDAO.get_journal_entries(
            start_date=date(2024, 1, 1),
            end_date=date(2024, 1, 31)
        )
        
        assert entries == []
    
    @patch('src.data_access.DatabaseManager')
    def test_search_journal_entries(self, mock_db_manager):
        """Test searching journal entries."""
        mock_db = Mock()
        mock_results = [
            {
                'id': 1,
                'entry_date': '2024-01-15',
                'entry_type': 'daily',
                'content': 'Did exercise today',
                'week_start_date': None,
                'month_year': None,
                'created_at': '2024-01-15T10:00:00',
                'updated_at': '2024-01-15T10:00:00'
            }
        ]
        mock_db.execute_query.return_value = mock_results
        mock_db_manager.return_value = mock_db
        
        entries = JournalDAO.search_journal_entries('exercise')
        
        assert len(entries) == 1
        assert 'exercise' in entries[0].content
        
        call_args = mock_db.execute_query.call_args
        params = call_args[0][1]
        assert params[0] == '%exercise%'
    
    @patch('src.data_access.DatabaseManager')
    def test_search_journal_entries_error(self, mock_db_manager):
        """Test error handling in search."""
        mock_db = Mock()
        mock_db.execute_query.side_effect = Exception("Search error")
        mock_db_manager.return_value = mock_db
        
        entries = JournalDAO.search_journal_entries('test')
        assert entries == []


class TestPreferenceDAO:
    """Test PreferenceDAO functionality."""
    
    @patch('src.data_access.DatabaseManager')
    def test_get_preference(self, mock_db_manager):
        """Test retrieving a preference value."""
        mock_db = Mock()
        mock_db.execute_query.return_value = [
            {'preference_value': 'true', 'data_type': 'boolean'}
        ]
        mock_db_manager.return_value = mock_db
        
        value = PreferenceDAO.get_preference('dark_mode', default=False)
        
        assert value is True
        call_args = mock_db.execute_query.call_args
        assert call_args[0][1] == ('dark_mode',)
    
    @patch('src.data_access.DatabaseManager')
    def test_get_preference_not_found(self, mock_db_manager):
        """Test getting preference with default value."""
        mock_db = Mock()
        mock_db.execute_query.return_value = []
        mock_db_manager.return_value = mock_db
        
        value = PreferenceDAO.get_preference('missing_pref', default='default_value')
        assert value == 'default_value'
    
    @patch('src.data_access.DatabaseManager')
    def test_get_preference_error(self, mock_db_manager):
        """Test error handling when getting preference."""
        mock_db = Mock()
        mock_db.execute_query.side_effect = Exception("Database error")
        mock_db_manager.return_value = mock_db
        
        value = PreferenceDAO.get_preference('test_pref', default='fallback')
        assert value == 'fallback'
    
    @patch('src.data_access.DatabaseManager')
    def test_set_preference(self, mock_db_manager):
        """Test setting a preference value."""
        mock_db = Mock()
        mock_db.execute_query.return_value = [{'data_type': 'integer'}]
        mock_db.execute_command.return_value = 1
        mock_db_manager.return_value = mock_db
        
        result = PreferenceDAO.set_preference('max_records', 1000)
        
        assert result is True
        
        # Check that value was converted to string
        update_call = mock_db.execute_command.call_args
        params = update_call[0][1]
        assert params[0] == '1000'  # Value as string
        assert params[1] == 'max_records'  # Key
    
    @patch('src.data_access.DatabaseManager')
    def test_set_preference_not_found(self, mock_db_manager):
        """Test setting non-existent preference."""
        mock_db = Mock()
        mock_db.execute_query.return_value = []
        mock_db_manager.return_value = mock_db
        
        result = PreferenceDAO.set_preference('new_pref', 'value')
        assert result is False
    
    @patch('src.data_access.DatabaseManager')
    def test_set_preference_error(self, mock_db_manager):
        """Test error handling when setting preference."""
        mock_db = Mock()
        mock_db.execute_query.side_effect = Exception("Update error")
        mock_db_manager.return_value = mock_db
        
        result = PreferenceDAO.set_preference('test_pref', 'value')
        assert result is False
    
    @patch('src.data_access.DatabaseManager')
    def test_get_all_preferences(self, mock_db_manager):
        """Test getting all preferences."""
        mock_db = Mock()
        mock_results = [
            {
                'preference_key': 'dark_mode',
                'preference_value': 'true',
                'data_type': 'boolean',
                'created_at': '2024-01-01T10:00:00',
                'updated_at': '2024-01-01T10:00:00'
            },
            {
                'preference_key': 'max_records',
                'preference_value': '1000',
                'data_type': 'integer',
                'created_at': '2024-01-01T10:00:00',
                'updated_at': '2024-01-01T10:00:00'
            }
        ]
        mock_db.execute_query.return_value = mock_results
        mock_db_manager.return_value = mock_db
        
        preferences = PreferenceDAO.get_all_preferences()
        
        assert preferences['dark_mode'] is True
        assert preferences['max_records'] == 1000
    
    @patch('src.data_access.DatabaseManager')
    def test_get_all_preferences_error(self, mock_db_manager):
        """Test error handling when getting all preferences."""
        mock_db = Mock()
        mock_db.execute_query.side_effect = Exception("Query error")
        mock_db_manager.return_value = mock_db
        
        preferences = PreferenceDAO.get_all_preferences()
        assert preferences == {}


class TestRecentFilesDAO:
    """Test RecentFilesDAO functionality."""
    
    @patch('src.data_access.DatabaseManager')
    def test_add_recent_file(self, mock_db_manager):
        """Test adding a recent file."""
        mock_db = Mock()
        mock_db.execute_command.return_value = 1
        mock_db_manager.return_value = mock_db
        
        file_id = RecentFilesDAO.add_recent_file(
            '/path/to/file.xml',
            file_size=1024000
        )
        
        assert file_id == 1
        
        # Check that cleanup was called
        assert mock_db.execute_command.call_count == 2
        cleanup_call = mock_db.execute_command.call_args_list[1]
        assert "DELETE FROM recent_files" in cleanup_call[0][0]
        assert "LIMIT 10" in cleanup_call[0][0]
    
    @patch('src.data_access.DatabaseManager')
    def test_add_recent_file_error(self, mock_db_manager):
        """Test error handling when adding file."""
        mock_db = Mock()
        mock_db.execute_command.side_effect = Exception("Insert error")
        mock_db_manager.return_value = mock_db
        
        with pytest.raises(Exception, match="Insert error"):
            RecentFilesDAO.add_recent_file('/path/to/file.xml')
    
    @patch('src.data_access.DatabaseManager')
    def test_get_recent_files(self, mock_db_manager):
        """Test getting recent files."""
        mock_db = Mock()
        mock_results = [
            {
                'id': 1,
                'file_path': '/path/to/file1.xml',
                'file_size': 1024000,
                'last_accessed': '2024-01-15T10:00:00',
                'is_valid': True
            },
            {
                'id': 2,
                'file_path': '/path/to/file2.xml',
                'file_size': 2048000,
                'last_accessed': '2024-01-14T10:00:00',
                'is_valid': True
            }
        ]
        mock_db.execute_query.return_value = mock_results
        mock_db_manager.return_value = mock_db
        
        files = RecentFilesDAO.get_recent_files(limit=5)
        
        assert len(files) == 2
        assert isinstance(files[0], RecentFile)
        assert files[0].file_path == '/path/to/file1.xml'
        
        call_args = mock_db.execute_query.call_args
        assert call_args[0][1] == (5,)
    
    @patch('src.data_access.DatabaseManager')
    def test_get_recent_files_error(self, mock_db_manager):
        """Test error handling when getting files."""
        mock_db = Mock()
        mock_db.execute_query.side_effect = Exception("Query error")
        mock_db_manager.return_value = mock_db
        
        files = RecentFilesDAO.get_recent_files()
        assert files == []
    
    @patch('src.data_access.DatabaseManager')
    def test_mark_file_invalid(self, mock_db_manager):
        """Test marking a file as invalid."""
        mock_db = Mock()
        mock_db.execute_command.return_value = 1
        mock_db_manager.return_value = mock_db
        
        result = RecentFilesDAO.mark_file_invalid('/path/to/file.xml')
        
        assert result is True
        call_args = mock_db.execute_command.call_args
        query = call_args[0][0]
        params = call_args[0][1]
        
        assert "UPDATE recent_files" in query
        assert "SET is_valid = FALSE" in query
        assert params[0] == '/path/to/file.xml'
    
    @patch('src.data_access.DatabaseManager')
    def test_mark_file_invalid_error(self, mock_db_manager):
        """Test error handling when marking file invalid."""
        mock_db = Mock()
        mock_db.execute_command.side_effect = Exception("Update error")
        mock_db_manager.return_value = mock_db
        
        result = RecentFilesDAO.mark_file_invalid('/path/to/file.xml')
        assert result is False


class TestCacheDAO:
    """Test CacheDAO functionality."""
    
    def test_generate_cache_key(self):
        """Test cache key generation."""
        key = CacheDAO._generate_cache_key(
            metric_type='steps',
            date_start=date(2024, 1, 1),
            date_end=date(2024, 1, 31),
            source_name='iPhone',
            health_type='StepCount',
            aggregation='daily'
        )
        
        assert isinstance(key, str)
        assert len(key) == 32  # MD5 hash length
        
        # Same inputs should generate same key
        key2 = CacheDAO._generate_cache_key(
            metric_type='steps',
            date_start=date(2024, 1, 1),
            date_end=date(2024, 1, 31),
            source_name='iPhone',
            health_type='StepCount',
            aggregation='daily'
        )
        assert key == key2
        
        # Different inputs should generate different keys
        key3 = CacheDAO._generate_cache_key(
            metric_type='steps',
            date_start=date(2024, 1, 1),
            date_end=date(2024, 1, 31),
            source_name='Apple Watch',  # Different source
            health_type='StepCount',
            aggregation='daily'
        )
        assert key != key3
    
    @patch('src.data_access.DatabaseManager')
    def test_cache_metrics(self, mock_db_manager):
        """Test caching metrics."""
        mock_db = Mock()
        mock_db.execute_command.return_value = 1
        mock_db_manager.return_value = mock_db
        
        test_data = {'values': [100, 200, 300], 'dates': ['2024-01-01', '2024-01-02']}
        
        cache_key = CacheDAO.cache_metrics(
            metric_type='steps',
            data=test_data,
            date_start=date(2024, 1, 1),
            date_end=date(2024, 1, 31),
            aggregation_type='daily',
            source_name='iPhone',
            health_type='StepCount',
            unit='count',
            record_count=100,
            min_value=1000.0,
            max_value=10000.0,
            avg_value=5000.0,
            ttl_hours=48
        )
        
        assert isinstance(cache_key, str)
        
        call_args = mock_db.execute_command.call_args
        query = call_args[0][0]
        params = call_args[0][1]
        
        assert "INSERT INTO cached_metrics" in query
        assert "ON CONFLICT(cache_key)" in query
        assert params[0] == cache_key
        assert params[1] == 'steps'
        assert json.loads(params[7]) == test_data
        assert params[8] == 'count'
        assert params[9] == 100
        assert params[10] == 1000.0
        assert params[11] == 10000.0
        assert params[12] == 5000.0
    
    @patch('src.data_access.DatabaseManager')
    def test_cache_metrics_error(self, mock_db_manager):
        """Test error handling when caching metrics."""
        mock_db = Mock()
        mock_db.execute_command.side_effect = Exception("Cache error")
        mock_db_manager.return_value = mock_db
        
        with pytest.raises(Exception, match="Cache error"):
            CacheDAO.cache_metrics(
                metric_type='steps',
                data={'test': 'data'},
                date_start=date(2024, 1, 1),
                date_end=date(2024, 1, 31)
            )
    
    @patch('src.data_access.DatabaseManager')
    def test_get_cached_metrics(self, mock_db_manager):
        """Test retrieving cached metrics."""
        mock_db = Mock()
        test_data = {'values': [100, 200, 300]}
        mock_db.execute_query.return_value = [
            {
                'metric_data': json.dumps(test_data),
                'expires_at': (datetime.now() + timedelta(hours=1)).isoformat()
            }
        ]
        mock_db_manager.return_value = mock_db
        
        result = CacheDAO.get_cached_metrics(
            metric_type='steps',
            date_start=date(2024, 1, 1),
            date_end=date(2024, 1, 31)
        )
        
        assert result == test_data
    
    @patch('src.data_access.DatabaseManager')
    def test_get_cached_metrics_expired(self, mock_db_manager):
        """Test retrieving expired cached metrics."""
        mock_db = Mock()
        mock_db.execute_query.return_value = []  # No non-expired results
        mock_db_manager.return_value = mock_db
        
        result = CacheDAO.get_cached_metrics(
            metric_type='steps',
            date_start=date(2024, 1, 1),
            date_end=date(2024, 1, 31)
        )
        
        assert result is None
    
    @patch('src.data_access.DatabaseManager')
    def test_get_cached_metrics_error(self, mock_db_manager):
        """Test error handling when retrieving cache."""
        mock_db = Mock()
        mock_db.execute_query.side_effect = Exception("Query error")
        mock_db_manager.return_value = mock_db
        
        result = CacheDAO.get_cached_metrics(
            metric_type='steps',
            date_start=date(2024, 1, 1),
            date_end=date(2024, 1, 31)
        )
        
        assert result is None
    
    @patch('src.data_access.DatabaseManager')
    def test_clean_expired_cache(self, mock_db_manager):
        """Test cleaning expired cache entries."""
        mock_db = Mock()
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_cursor.rowcount = 5
        mock_conn.cursor.return_value = mock_cursor
        mock_db.get_connection.return_value.__enter__.return_value = mock_conn
        mock_db.get_connection.return_value.__exit__.return_value = None
        mock_db_manager.return_value = mock_db
        
        deleted_count = CacheDAO.clean_expired_cache()
        
        assert deleted_count == 5
        mock_cursor.execute.assert_called_once()
        query = mock_cursor.execute.call_args[0][0]
        assert "DELETE FROM cached_metrics" in query
        assert "expires_at <= datetime('now')" in query
    
    @patch('src.data_access.DatabaseManager')
    def test_clean_expired_cache_error(self, mock_db_manager):
        """Test error handling when cleaning cache."""
        mock_db = Mock()
        mock_db.get_connection.side_effect = Exception("Connection error")
        mock_db_manager.return_value = mock_db
        
        deleted_count = CacheDAO.clean_expired_cache()
        assert deleted_count == 0


class TestMetricsMetadataDAO:
    """Test MetricsMetadataDAO functionality."""
    
    @patch('src.data_access.DatabaseManager')
    def test_get_metric_metadata(self, mock_db_manager):
        """Test getting metric metadata."""
        mock_db = Mock()
        mock_db.execute_query.return_value = [
            {
                'metric_type': 'StepCount',
                'display_name': 'Steps',
                'unit': 'count',
                'category': 'Activity',
                'color_hex': '#FF5733',
                'icon_name': 'footsteps'
            }
        ]
        mock_db_manager.return_value = mock_db
        
        metadata = MetricsMetadataDAO.get_metric_metadata('StepCount')
        
        assert metadata['display_name'] == 'Steps'
        assert metadata['unit'] == 'count'
        assert metadata['category'] == 'Activity'
    
    @patch('src.data_access.DatabaseManager')
    def test_get_metric_metadata_not_found(self, mock_db_manager):
        """Test getting non-existent metadata."""
        mock_db = Mock()
        mock_db.execute_query.return_value = []
        mock_db_manager.return_value = mock_db
        
        metadata = MetricsMetadataDAO.get_metric_metadata('UnknownType')
        assert metadata is None
    
    @patch('src.data_access.DatabaseManager')
    def test_get_metric_metadata_error(self, mock_db_manager):
        """Test error handling when getting metadata."""
        mock_db = Mock()
        mock_db.execute_query.side_effect = Exception("Query error")
        mock_db_manager.return_value = mock_db
        
        metadata = MetricsMetadataDAO.get_metric_metadata('StepCount')
        assert metadata is None
    
    @patch('src.data_access.DatabaseManager')
    def test_update_metric_metadata(self, mock_db_manager):
        """Test updating metric metadata."""
        mock_db = Mock()
        mock_db.execute_command.return_value = 1
        mock_db_manager.return_value = mock_db
        
        result = MetricsMetadataDAO.update_metric_metadata(
            metric_type='StepCount',
            display_name='Daily Steps',
            category='Fitness',
            unit='steps',
            color_hex='#00FF00',
            icon_name='walking'
        )
        
        assert result is True
        
        call_args = mock_db.execute_command.call_args
        query = call_args[0][0]
        params = call_args[0][1]
        
        assert "INSERT INTO health_metrics_metadata" in query
        assert "ON CONFLICT(metric_type)" in query
        assert params[0] == 'StepCount'
        assert params[1] == 'Daily Steps'
        assert params[4] == '#00FF00'
    
    @patch('src.data_access.DatabaseManager')
    def test_update_metric_metadata_error(self, mock_db_manager):
        """Test error handling when updating metadata."""
        mock_db = Mock()
        mock_db.execute_command.side_effect = Exception("Update error")
        mock_db_manager.return_value = mock_db
        
        result = MetricsMetadataDAO.update_metric_metadata(
            metric_type='StepCount',
            display_name='Steps'
        )
        
        assert result is False
    
    @patch('src.data_access.DatabaseManager')
    def test_get_metrics_by_category(self, mock_db_manager):
        """Test getting metrics by category."""
        mock_db = Mock()
        mock_db.execute_query.return_value = [
            {
                'metric_type': 'StepCount',
                'display_name': 'Steps',
                'category': 'Activity'
            },
            {
                'metric_type': 'DistanceWalkingRunning',
                'display_name': 'Walking + Running Distance',
                'category': 'Activity'
            }
        ]
        mock_db_manager.return_value = mock_db
        
        metrics = MetricsMetadataDAO.get_metrics_by_category('Activity')
        
        assert len(metrics) == 2
        assert metrics[0]['metric_type'] == 'StepCount'
        assert all(m['category'] == 'Activity' for m in metrics)
    
    @patch('src.data_access.DatabaseManager')
    def test_get_metrics_by_category_error(self, mock_db_manager):
        """Test error handling when getting by category."""
        mock_db = Mock()
        mock_db.execute_query.side_effect = Exception("Query error")
        mock_db_manager.return_value = mock_db
        
        metrics = MetricsMetadataDAO.get_metrics_by_category('Activity')
        assert metrics == []


class TestDataSourceDAO:
    """Test DataSourceDAO functionality."""
    
    @patch('src.data_access.DatabaseManager')
    def test_register_data_source(self, mock_db_manager):
        """Test registering a data source."""
        mock_db = Mock()
        mock_db.execute_command.return_value = 1
        mock_db_manager.return_value = mock_db
        
        source_id = DataSourceDAO.register_data_source(
            'iPhone 14 Pro',
            category='Device'
        )
        
        assert source_id == 1
        
        call_args = mock_db.execute_command.call_args
        query = call_args[0][0]
        params = call_args[0][1]
        
        assert "INSERT INTO data_sources" in query
        assert "ON CONFLICT(source_name)" in query
        assert params[0] == 'iPhone 14 Pro'
        assert params[1] == 'Device'
    
    @patch('src.data_access.DatabaseManager')
    def test_register_data_source_error(self, mock_db_manager):
        """Test error handling when registering source."""
        mock_db = Mock()
        mock_db.execute_command.side_effect = Exception("Insert error")
        mock_db_manager.return_value = mock_db
        
        with pytest.raises(Exception, match="Insert error"):
            DataSourceDAO.register_data_source('iPhone')
    
    @patch('src.data_access.DatabaseManager')
    def test_get_active_sources(self, mock_db_manager):
        """Test getting active sources."""
        mock_db = Mock()
        mock_db.execute_query.return_value = [
            {'source_name': 'iPhone', 'is_active': True},
            {'source_name': 'Apple Watch', 'is_active': True}
        ]
        mock_db_manager.return_value = mock_db
        
        sources = DataSourceDAO.get_active_sources()
        
        assert len(sources) == 2
        assert sources[0]['source_name'] == 'iPhone'
    
    @patch('src.data_access.DatabaseManager')
    def test_get_active_sources_error(self, mock_db_manager):
        """Test error handling when getting sources."""
        mock_db = Mock()
        mock_db.execute_query.side_effect = Exception("Query error")
        mock_db_manager.return_value = mock_db
        
        sources = DataSourceDAO.get_active_sources()
        assert sources == []
    
    @patch('src.data_access.DatabaseManager')
    def test_update_source_activity(self, mock_db_manager):
        """Test updating source activity."""
        mock_db = Mock()
        mock_db.execute_command.return_value = 1
        mock_db_manager.return_value = mock_db
        
        result = DataSourceDAO.update_source_activity('iPhone')
        
        assert result is True
        
        call_args = mock_db.execute_command.call_args
        query = call_args[0][0]
        params = call_args[0][1]
        
        assert "UPDATE data_sources" in query
        assert "SET last_seen = CURRENT_TIMESTAMP" in query
        assert params[0] == 'iPhone'
    
    @patch('src.data_access.DatabaseManager')
    def test_update_source_activity_error(self, mock_db_manager):
        """Test error handling when updating activity."""
        mock_db = Mock()
        mock_db.execute_command.side_effect = Exception("Update error")
        mock_db_manager.return_value = mock_db
        
        result = DataSourceDAO.update_source_activity('iPhone')
        assert result is False


class TestImportHistoryDAO:
    """Test ImportHistoryDAO functionality."""
    
    @patch('src.data_access.DatabaseManager')
    def test_record_import(self, mock_db_manager):
        """Test recording import history."""
        mock_db = Mock()
        mock_db.execute_command.return_value = 1
        mock_db_manager.return_value = mock_db
        
        import_id = ImportHistoryDAO.record_import(
            file_path='/path/to/export.xml',
            file_hash='abc123def456',
            row_count=10000,
            date_range_start=date(2023, 1, 1),
            date_range_end=date(2024, 1, 1),
            unique_types=15,
            unique_sources=3,
            import_duration_ms=5000
        )
        
        assert import_id == 1
        
        call_args = mock_db.execute_command.call_args
        params = call_args[0][1]
        
        assert params[0] == '/path/to/export.xml'
        assert params[1] == 'abc123def456'
        assert params[2] == 10000
        assert params[3] == '2023-01-01'
        assert params[4] == '2024-01-01'
        assert params[5] == 15
        assert params[6] == 3
        assert params[7] == 5000
    
    @patch('src.data_access.DatabaseManager')
    def test_record_import_minimal(self, mock_db_manager):
        """Test recording import with minimal data."""
        mock_db = Mock()
        mock_db.execute_command.return_value = 2
        mock_db_manager.return_value = mock_db
        
        import_id = ImportHistoryDAO.record_import(
            file_path='/path/to/export.xml'
        )
        
        assert import_id == 2
        
        call_args = mock_db.execute_command.call_args
        params = call_args[0][1]
        
        assert params[0] == '/path/to/export.xml'
        assert all(p is None for p in params[1:])
    
    @patch('src.data_access.DatabaseManager')
    def test_record_import_error(self, mock_db_manager):
        """Test error handling when recording import."""
        mock_db = Mock()
        mock_db.execute_command.side_effect = Exception("Insert error")
        mock_db_manager.return_value = mock_db
        
        with pytest.raises(Exception, match="Insert error"):
            ImportHistoryDAO.record_import('/path/to/file.xml')
    
    @patch('src.data_access.DatabaseManager')
    def test_get_import_history(self, mock_db_manager):
        """Test getting import history."""
        mock_db = Mock()
        mock_db.execute_query.return_value = [
            {
                'id': 1,
                'file_path': '/path/to/export1.xml',
                'import_date': '2024-01-15T10:00:00',
                'row_count': 10000
            },
            {
                'id': 2,
                'file_path': '/path/to/export2.xml',
                'import_date': '2024-01-14T10:00:00',
                'row_count': 5000
            }
        ]
        mock_db_manager.return_value = mock_db
        
        history = ImportHistoryDAO.get_import_history(limit=5)
        
        assert len(history) == 2
        assert history[0]['file_path'] == '/path/to/export1.xml'
        
        call_args = mock_db.execute_query.call_args
        assert call_args[0][1] == (5,)
    
    @patch('src.data_access.DatabaseManager')
    def test_get_import_history_error(self, mock_db_manager):
        """Test error handling when getting history."""
        mock_db = Mock()
        mock_db.execute_query.side_effect = Exception("Query error")
        mock_db_manager.return_value = mock_db
        
        history = ImportHistoryDAO.get_import_history()
        assert history == []
    
    @patch('src.data_access.DatabaseManager')
    def test_is_file_imported(self, mock_db_manager):
        """Test checking if file is imported."""
        mock_db = Mock()
        mock_db.execute_query.return_value = [[1]]  # COUNT(*) result
        mock_db_manager.return_value = mock_db
        
        result = ImportHistoryDAO.is_file_imported('abc123def456')
        
        assert result is True
        
        call_args = mock_db.execute_query.call_args
        query = call_args[0][0]
        params = call_args[0][1]
        
        assert "SELECT COUNT(*)" in query
        assert "WHERE file_hash = ?" in query
        assert params[0] == 'abc123def456'
    
    @patch('src.data_access.DatabaseManager')
    def test_is_file_imported_not_found(self, mock_db_manager):
        """Test checking non-imported file."""
        mock_db = Mock()
        mock_db.execute_query.return_value = [[0]]
        mock_db_manager.return_value = mock_db
        
        result = ImportHistoryDAO.is_file_imported('nonexistent')
        assert result is False
    
    @patch('src.data_access.DatabaseManager')
    def test_is_file_imported_error(self, mock_db_manager):
        """Test error handling when checking import."""
        mock_db = Mock()
        mock_db.execute_query.side_effect = Exception("Query error")
        mock_db_manager.return_value = mock_db
        
        result = ImportHistoryDAO.is_file_imported('abc123')
        assert result is False