"""
Comprehensive test suite for Statistics Calculator with high coverage.
Tests all statistical methods, edge cases, and error handling.
"""

import pytest
import pandas as pd
import numpy as np
from datetime import datetime, timezone
from unittest.mock import Mock, patch
import math

from src.statistics_calculator import (
    StatisticsCalculator, BasicStatistics
)


class TestBasicStatistics:
    """Test BasicStatistics data class."""
    
    def test_init(self):
        """Test BasicStatistics initialization."""
        stats = BasicStatistics(
            total_records=100,
            date_range=(datetime(2024, 1, 1), datetime(2024, 12, 31)),
            records_by_type={'StepCount': 50, 'HeartRate': 50},
            records_by_source={'iPhone': 60, 'Apple Watch': 40},
            types_by_source={'iPhone': ['StepCount'], 'Apple Watch': ['HeartRate']}
        )
        
        assert stats.total_records == 100
        assert stats.date_range[0] == datetime(2024, 1, 1)
        assert stats.records_by_type['StepCount'] == 50
        assert stats.records_by_source['iPhone'] == 60
        assert 'StepCount' in stats.types_by_source['iPhone']
    
    def test_to_dict(self):
        """Test conversion to dictionary."""
        date_start = datetime(2024, 1, 1, tzinfo=timezone.utc)
        date_end = datetime(2024, 12, 31, tzinfo=timezone.utc)
        
        stats = BasicStatistics(
            total_records=100,
            date_range=(date_start, date_end),
            records_by_type={'StepCount': 50},
            records_by_source={'iPhone': 60},
            types_by_source={'iPhone': ['StepCount']}
        )
        
        result = stats.to_dict()
        
        assert result['total_records'] == 100
        assert result['date_range']['start'] == date_start.isoformat()
        assert result['date_range']['end'] == date_end.isoformat()
        assert result['records_by_type']['StepCount'] == 50
    
    def test_to_dict_with_none_dates(self):
        """Test to_dict with None date values."""
        stats = BasicStatistics(
            total_records=0,
            date_range=(None, None),
            records_by_type={},
            records_by_source={},
            types_by_source={}
        )
        
        result = stats.to_dict()
        assert result['date_range']['start'] is None
        assert result['date_range']['end'] is None


class TestStatisticsCalculator:
    """Test StatisticsCalculator main functionality."""
    
    @pytest.fixture
    def calculator(self):
        """Create a StatisticsCalculator instance."""
        return StatisticsCalculator()
    
    @pytest.fixture
    def sample_df(self):
        """Create sample health data DataFrame."""
        return pd.DataFrame({
            'creationDate': pd.to_datetime([
                '2024-01-01T10:00:00Z',
                '2024-01-02T11:00:00Z',
                '2024-01-03T12:00:00Z',
                '2024-01-04T13:00:00Z',
                '2024-01-05T14:00:00Z'
            ]),
            'type': ['StepCount', 'HeartRate', 'StepCount', 'HeartRate', 'StepCount'],
            'sourceName': ['iPhone', 'Apple Watch', 'iPhone', 'Apple Watch', 'iPhone'],
            'value': [5000, 72, 6000, 75, 7000]
        })
    
    def test_calculate_from_empty_dataframe(self, calculator):
        """Test calculation with empty DataFrame."""
        df = pd.DataFrame()
        stats = calculator.calculate_from_dataframe(df)
        
        assert stats.total_records == 0
        assert stats.date_range == (None, None)
        assert stats.records_by_type == {}
        assert stats.records_by_source == {}
        assert stats.types_by_source == {}
    
    def test_calculate_from_dataframe(self, calculator, sample_df):
        """Test calculation with sample data."""
        stats = calculator.calculate_from_dataframe(sample_df)
        
        assert stats.total_records == 5
        assert stats.date_range[0].date() == pd.Timestamp('2024-01-01').date()
        assert stats.date_range[1].date() == pd.Timestamp('2024-01-05').date()
        assert stats.records_by_type['StepCount'] == 3
        assert stats.records_by_type['HeartRate'] == 2
        assert stats.records_by_source['iPhone'] == 3
        assert stats.records_by_source['Apple Watch'] == 2
        assert 'StepCount' in stats.types_by_source['iPhone']
        assert 'HeartRate' in stats.types_by_source['Apple Watch']
    
    def test_calculate_with_mixed_date_formats(self, calculator):
        """Test handling of mixed date formats."""
        df = pd.DataFrame({
            'creationDate': [
                '2024-01-01T10:00:00Z',
                '2024-01-02 11:00:00',
                '01/03/2024 12:00:00',
                'invalid_date'
            ],
            'type': ['StepCount'] * 4,
            'sourceName': ['iPhone'] * 4,
            'value': [1000] * 4
        })
        
        stats = calculator.calculate_from_dataframe(df)
        
        # Should handle mixed formats
        assert stats.total_records == 4
        assert stats.date_range[0] is not None
    
    def test_calculate_with_invalid_dates(self, calculator):
        """Test handling of completely invalid dates."""
        df = pd.DataFrame({
            'creationDate': ['invalid1', 'invalid2', 'invalid3'],
            'type': ['StepCount'] * 3,
            'sourceName': ['iPhone'] * 3,
            'value': [1000] * 3
        })
        
        with patch('pandas.to_datetime', side_effect=Exception("Parse error")):
            stats = calculator.calculate_from_dataframe(df)
            assert stats.date_range == (None, None)
    
    def test_calculate_from_database_no_loader(self, calculator):
        """Test database calculation without data loader."""
        with pytest.raises(ValueError, match="DataLoader not provided"):
            calculator.calculate_from_database()
    
    def test_calculate_from_database_with_filters(self, calculator, sample_df):
        """Test database calculation with filters."""
        mock_loader = Mock()
        mock_loader.get_all_records.return_value = sample_df
        
        calculator.data_loader = mock_loader
        
        stats = calculator.calculate_from_database(
            start_date=datetime(2024, 1, 2),
            end_date=datetime(2024, 1, 4),
            types=['StepCount'],
            sources=['iPhone']
        )
        
        # Should filter to 1 record (Jan 3)
        assert stats.total_records == 1
        assert stats.records_by_type['StepCount'] == 1
    
    def test_calculate_from_database_error(self, calculator):
        """Test error handling in database calculation."""
        mock_loader = Mock()
        mock_loader.get_all_records.side_effect = Exception("Database error")
        
        calculator.data_loader = mock_loader
        
        with pytest.raises(ValueError, match="Failed to calculate statistics from database"):
            calculator.calculate_from_database()
    
    def test_get_quick_summary(self, calculator, sample_df):
        """Test human-readable summary generation."""
        stats = calculator.calculate_from_dataframe(sample_df)
        summary = calculator.get_quick_summary(stats)
        
        assert "Total Records: 5" in summary
        assert "Date Range: 2024-01-01 to 2024-01-05" in summary
        assert "Top 5 Record Types:" in summary
        assert "StepCount: 3" in summary
        assert "HeartRate: 2" in summary
        assert "Data Sources (2):" in summary
        assert "iPhone: 3 records" in summary
        assert "Apple Watch: 2 records" in summary
    
    def test_get_quick_summary_empty(self, calculator):
        """Test summary for empty statistics."""
        stats = BasicStatistics(
            total_records=0,
            date_range=(None, None),
            records_by_type={},
            records_by_source={},
            types_by_source={}
        )
        
        summary = calculator.get_quick_summary(stats)
        assert summary == "No health records found."
    
    def test_calculate_descriptive_stats(self, calculator):
        """Test descriptive statistics calculation."""
        data = pd.Series([1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 10])
        stats = calculator.calculate_descriptive_stats(data)
        
        assert stats['mean'] == pytest.approx(5.45, rel=0.01)
        assert stats['median'] == 5.0
        assert stats['std'] > 0
        assert stats['var'] > 0
        assert stats['min'] == 1.0
        assert stats['max'] == 10.0
        assert stats['range'] == 9.0
        assert stats['q1'] == pytest.approx(3.5, rel=0.1)
        assert stats['q3'] == pytest.approx(7.5, rel=0.1)
        assert stats['iqr'] == pytest.approx(4.0, rel=0.1)
        assert 'skewness' in stats
        assert 'kurtosis' in stats
        assert stats['mode'] == 5.0
    
    def test_calculate_descriptive_stats_empty(self, calculator):
        """Test descriptive stats with empty data."""
        data = pd.Series([])
        stats = calculator.calculate_descriptive_stats(data)
        assert stats == {}
    
    def test_calculate_descriptive_stats_all_nan(self, calculator):
        """Test descriptive stats with all NaN values."""
        data = pd.Series([np.nan, np.nan, np.nan])
        stats = calculator.calculate_descriptive_stats(data)
        assert stats == {}
    
    def test_calculate_descriptive_stats_single_value(self, calculator):
        """Test descriptive stats with single value."""
        data = pd.Series([5.0])
        stats = calculator.calculate_descriptive_stats(data)
        
        assert stats['mean'] == 5.0
        assert stats['std'] == 0.0
        assert stats['skewness'] == 0.0
        assert stats['kurtosis'] == 0.0
    
    def test_calculate_correlation_matrix(self, calculator):
        """Test correlation matrix calculation."""
        df = pd.DataFrame({
            'value1': [1, 2, 3, 4, 5],
            'value2': [2, 4, 6, 8, 10],
            'value3': [5, 4, 3, 2, 1],
            'category': ['A', 'B', 'A', 'B', 'A']
        })
        
        corr_matrix = calculator.calculate_correlation_matrix(df)
        
        assert corr_matrix.shape == (3, 3)
        assert corr_matrix.loc['value1', 'value2'] == pytest.approx(1.0)
        assert corr_matrix.loc['value1', 'value3'] == pytest.approx(-1.0)
    
    def test_calculate_correlation_matrix_insufficient_columns(self, calculator):
        """Test correlation matrix with insufficient numeric columns."""
        df = pd.DataFrame({
            'value': [1, 2, 3],
            'category': ['A', 'B', 'C']
        })
        
        corr_matrix = calculator.calculate_correlation_matrix(df)
        assert corr_matrix.empty
    
    def test_analyze_distribution(self, calculator):
        """Test distribution analysis."""
        # Normal distribution
        np.random.seed(42)
        normal_data = pd.Series(np.random.normal(0, 1, 1000))
        result = calculator.analyze_distribution(normal_data)
        
        assert result['distribution_type'] == 'approximately_normal'
        assert 'normality_test' in result
        assert abs(result['skewness']) < 0.5
        
        # Right-skewed distribution
        skewed_data = pd.Series(np.random.exponential(1, 1000))
        result = calculator.analyze_distribution(skewed_data)
        
        assert result['distribution_type'] == 'right_skewed'
        assert result['skewness'] > 0.5
        
        # Left-skewed distribution
        left_skewed = pd.Series(-np.random.exponential(1, 1000))
        result = calculator.analyze_distribution(left_skewed)
        
        assert result['distribution_type'] == 'left_skewed'
        assert result['skewness'] < -0.5
    
    def test_analyze_distribution_small_sample(self, calculator):
        """Test distribution analysis with small sample."""
        data = pd.Series([1, 2, 3])
        result = calculator.analyze_distribution(data)
        
        assert result['distribution_type'] == 'insufficient_data'
        assert result['normality_test'] is None
    
    @patch('scipy.stats.shapiro')
    def test_analyze_distribution_large_sample(self, mock_shapiro, calculator):
        """Test distribution analysis with large sample using Anderson-Darling."""
        # Create large sample
        data = pd.Series(np.random.normal(0, 1, 6000))
        
        with patch('scipy.stats.anderson') as mock_anderson:
            mock_anderson.return_value = Mock(
                statistic=0.5,
                critical_values=[0.574, 0.653, 0.784, 0.914, 1.088]
            )
            
            result = calculator.analyze_distribution(data)
            
            assert result['normality_test']['test'] == 'anderson'
            assert result['normality_test']['statistic'] == 0.5
            mock_shapiro.assert_not_called()
    
    def test_analyze_distribution_no_scipy(self, calculator):
        """Test distribution analysis without scipy."""
        data = pd.Series([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
        
        with patch('scipy.stats', side_effect=ImportError):
            result = calculator.analyze_distribution(data)
            
            assert result['distribution_type'] == 'unknown'
            assert result['normality_test'] is None
            assert 'skewness' in result
    
    def test_analyze_time_series(self, calculator):
        """Test time series analysis."""
        # Create trending data
        dates = pd.date_range('2024-01-01', periods=30, freq='D')
        values = pd.Series(range(30)) + np.random.normal(0, 1, 30)
        
        result = calculator.analyze_time_series(pd.Series(dates), values)
        
        assert result['trend']['direction'] == 'increasing'
        assert result['trend']['slope'] > 0.01
        assert result['seasonality'] == 'not_analyzed'
        
        # Decreasing trend
        decreasing_values = pd.Series(range(30, 0, -1)) + np.random.normal(0, 1, 30)
        result = calculator.analyze_time_series(pd.Series(dates), decreasing_values)
        
        assert result['trend']['direction'] == 'decreasing'
        assert result['trend']['slope'] < -0.01
        
        # Stable trend
        stable_values = pd.Series([5] * 30) + np.random.normal(0, 0.001, 30)
        result = calculator.analyze_time_series(pd.Series(dates), stable_values)
        
        assert result['trend']['direction'] == 'stable'
    
    def test_analyze_time_series_insufficient_data(self, calculator):
        """Test time series with insufficient data."""
        dates = pd.Series([datetime(2024, 1, 1)])
        values = pd.Series([100])
        
        result = calculator.analyze_time_series(dates, values)
        
        assert result['trend'] is None
        assert result['seasonality'] is None
    
    def test_analyze_time_series_mismatched_lengths(self, calculator):
        """Test time series with mismatched lengths."""
        dates = pd.Series([datetime(2024, 1, 1), datetime(2024, 1, 2)])
        values = pd.Series([100])
        
        result = calculator.analyze_time_series(dates, values)
        
        assert result['trend'] is None
        assert result['seasonality'] is None
    
    def test_analyze_time_series_error(self, calculator):
        """Test time series analysis error handling."""
        dates = pd.Series(['invalid', 'dates'])
        values = pd.Series([1, 2])
        
        result = calculator.analyze_time_series(dates, values)
        
        assert result['trend'] is None
        assert result['seasonality'] is None
    
    def test_perform_statistical_tests(self, calculator):
        """Test statistical tests between groups."""
        # Create two different groups
        np.random.seed(42)
        group1 = pd.Series(np.random.normal(10, 2, 100))
        group2 = pd.Series(np.random.normal(12, 2, 100))
        
        result = calculator.perform_statistical_tests(group1, group2)
        
        assert 't_test' in result
        assert 'statistic' in result['t_test']
        assert 'p_value' in result['t_test']
        assert result['t_test']['p_value'] < 0.05  # Should be significantly different
        
        assert 'mann_whitney' in result
        assert 'statistic' in result['mann_whitney']
        assert 'p_value' in result['mann_whitney']
    
    def test_perform_statistical_tests_small_samples(self, calculator):
        """Test statistical tests with small samples."""
        group1 = pd.Series([1])
        group2 = pd.Series([2])
        
        result = calculator.perform_statistical_tests(group1, group2)
        
        assert result['t_test'] is None
        assert result['mann_whitney'] is None
    
    def test_perform_statistical_tests_no_scipy(self, calculator):
        """Test statistical tests without scipy."""
        group1 = pd.Series([1, 2, 3, 4, 5])
        group2 = pd.Series([6, 7, 8, 9, 10])
        
        with patch('scipy.stats', side_effect=ImportError):
            result = calculator.perform_statistical_tests(group1, group2)
            
            assert result['t_test'] is None
            assert result['mann_whitney'] is None
    
    def test_calculate_confidence_interval(self, calculator):
        """Test confidence interval calculation."""
        np.random.seed(42)
        data = pd.Series(np.random.normal(100, 10, 1000))
        
        # 95% confidence interval
        ci_95 = calculator.calculate_confidence_interval(data, 0.95)
        assert ci_95['lower'] < 100
        assert ci_95['upper'] > 100
        assert ci_95['upper'] - ci_95['lower'] < 2  # Should be relatively narrow
        
        # 99% confidence interval
        ci_99 = calculator.calculate_confidence_interval(data, 0.99)
        assert ci_99['upper'] - ci_99['lower'] > ci_95['upper'] - ci_95['lower']
    
    def test_calculate_confidence_interval_small_sample(self, calculator):
        """Test confidence interval with small sample."""
        data = pd.Series([1, 2, 3, 4, 5])
        
        ci = calculator.calculate_confidence_interval(data, 0.95)
        assert ci['lower'] < 3  # Mean is 3
        assert ci['upper'] > 3
    
    def test_calculate_confidence_interval_insufficient_data(self, calculator):
        """Test confidence interval with insufficient data."""
        data = pd.Series([5])
        
        ci = calculator.calculate_confidence_interval(data, 0.95)
        assert ci['lower'] is None
        assert ci['upper'] is None
    
    def test_calculate_confidence_interval_no_scipy(self, calculator):
        """Test confidence interval without scipy."""
        data = pd.Series(np.random.normal(100, 10, 100))
        
        with patch('scipy.stats', side_effect=ImportError):
            # Large sample (n >= 30)
            ci = calculator.calculate_confidence_interval(data, 0.95)
            assert ci['lower'] < 100
            assert ci['upper'] > 100
            
            # Small sample
            small_data = pd.Series([1, 2, 3, 4, 5])
            ci_small = calculator.calculate_confidence_interval(small_data, 0.95)
            assert ci_small['lower'] < 3
            assert ci_small['upper'] > 3
    
    def test_bootstrap_statistics(self, calculator):
        """Test bootstrap statistics calculation."""
        np.random.seed(42)
        data = pd.Series(np.random.exponential(2, 100))
        
        # Bootstrap mean
        result = calculator.bootstrap_statistics(data, n_bootstrap=100)
        
        assert 'estimate' in result
        assert result['estimate'] == pytest.approx(np.mean(data), rel=0.1)
        assert 'confidence_interval' in result
        assert result['confidence_interval']['lower'] < result['estimate']
        assert result['confidence_interval']['upper'] > result['estimate']
        assert 'standard_error' in result
        assert result['standard_error'] > 0
        
        # Bootstrap median
        result_median = calculator.bootstrap_statistics(
            data, 
            statistic=np.median,
            n_bootstrap=100
        )
        
        assert result_median['estimate'] == pytest.approx(np.median(data), rel=0.1)
    
    def test_bootstrap_statistics_insufficient_data(self, calculator):
        """Test bootstrap with insufficient data."""
        data = pd.Series([5])
        
        result = calculator.bootstrap_statistics(data)
        
        assert result['estimate'] is None
        assert result['confidence_interval'] is None
        assert result['standard_error'] is None
    
    def test_bootstrap_statistics_custom_function(self, calculator):
        """Test bootstrap with custom statistic function."""
        data = pd.Series([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
        
        def custom_stat(x):
            return np.percentile(x, 75) - np.percentile(x, 25)  # IQR
        
        result = calculator.bootstrap_statistics(
            data,
            statistic=custom_stat,
            n_bootstrap=50
        )
        
        assert result['estimate'] == pytest.approx(custom_stat(data.values), rel=0.1)
        assert 'confidence_interval' in result
        assert 'standard_error' in result


class TestIntegration:
    """Integration tests for statistics calculator."""
    
    def test_full_statistics_workflow(self):
        """Test complete statistics calculation workflow."""
        # Create comprehensive test data
        dates = pd.date_range('2024-01-01', periods=100, freq='D')
        
        data_records = []
        for i, date in enumerate(dates):
            # Steps data
            data_records.append({
                'creationDate': date,
                'type': 'StepCount',
                'sourceName': 'iPhone',
                'value': 5000 + np.random.randint(-2000, 3000)
            })
            
            # Heart rate data
            if i % 2 == 0:
                data_records.append({
                    'creationDate': date,
                    'type': 'HeartRate',
                    'sourceName': 'Apple Watch',
                    'value': 70 + np.random.randint(-10, 10)
                })
        
        df = pd.DataFrame(data_records)
        
        calculator = StatisticsCalculator()
        
        # Calculate basic statistics
        basic_stats = calculator.calculate_from_dataframe(df)
        assert basic_stats.total_records == 150
        assert basic_stats.records_by_type['StepCount'] == 100
        assert basic_stats.records_by_type['HeartRate'] == 50
        
        # Get summary
        summary = calculator.get_quick_summary(basic_stats)
        assert "Total Records: 150" in summary
        
        # Calculate descriptive statistics for steps
        steps_data = df[df['type'] == 'StepCount']['value']
        desc_stats = calculator.calculate_descriptive_stats(steps_data)
        assert 'mean' in desc_stats
        assert 'std' in desc_stats
        
        # Analyze distribution
        dist_analysis = calculator.analyze_distribution(steps_data)
        assert 'distribution_type' in dist_analysis
        
        # Time series analysis
        steps_df = df[df['type'] == 'StepCount']
        ts_analysis = calculator.analyze_time_series(
            steps_df['creationDate'],
            steps_df['value']
        )
        assert 'trend' in ts_analysis
        
        # Compare two groups
        iphone_steps = df[(df['type'] == 'StepCount') & (df['sourceName'] == 'iPhone')]['value']
        watch_hr = df[(df['type'] == 'HeartRate') & (df['sourceName'] == 'Apple Watch')]['value']
        
        if len(iphone_steps) > 2 and len(watch_hr) > 2:
            test_results = calculator.perform_statistical_tests(iphone_steps, watch_hr)
            assert 't_test' in test_results
    
    def test_edge_cases_comprehensive(self):
        """Test various edge cases comprehensively."""
        calculator = StatisticsCalculator()
        
        # Test with various problematic data
        edge_cases = [
            pd.DataFrame(),  # Empty
            pd.DataFrame({'type': [], 'value': []}),  # Empty with columns
            pd.DataFrame({'type': [None], 'value': [None]}),  # All None
            pd.DataFrame({'type': ['Test'], 'value': [np.inf]}),  # Infinity
            pd.DataFrame({'type': ['Test'], 'value': [-np.inf]}),  # Negative infinity
            pd.DataFrame({'type': ['Test'], 'value': [np.nan]}),  # NaN
        ]
        
        for df in edge_cases:
            # Should not raise exceptions
            stats = calculator.calculate_from_dataframe(df)
            assert isinstance(stats, BasicStatistics)