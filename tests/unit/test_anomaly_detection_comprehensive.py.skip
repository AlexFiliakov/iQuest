"""Comprehensive tests for anomaly detection modules."""

import pytest
from datetime import date, datetime, timedelta
from unittest.mock import Mock, patch, MagicMock
import numpy as np
import pandas as pd

from src.analytics.anomaly_detection import (
    AnomalyDetectionSystem,
    ZScoreDetector, IQRDetector, IsolationForestDetector,
    LocalOutlierFactorDetector, LSTMDetector, EnsembleDetector,
    Anomaly, Severity, DetectionMethod,
    DetectionConfig, DetectionResult
)


class TestAnomalyModels:
    """Test anomaly model classes."""
    
    def test_severity_enum(self):
        """Test Severity enumeration."""
        assert Severity.LOW.value == "low"
        assert Severity.MEDIUM.value == "medium"
        assert Severity.HIGH.value == "high"
        assert Severity.CRITICAL.value == "critical"
        
    def test_detection_method_enum(self):
        """Test DetectionMethod enumeration."""
        assert DetectionMethod.ZSCORE.value == "zscore"
        assert DetectionMethod.MODIFIED_ZSCORE.value == "modified_zscore"
        assert DetectionMethod.IQR.value == "iqr"
        assert DetectionMethod.ISOLATION_FOREST.value == "isolation_forest"
        assert DetectionMethod.LOF.value == "lof"
        assert DetectionMethod.LSTM.value == "lstm"
        assert DetectionMethod.ENSEMBLE.value == "ensemble"
        
        
    def test_anomaly_creation(self):
        """Test creating Anomaly instance."""
        anomaly = Anomaly(
            timestamp=datetime(2023, 1, 1),
            metric="steps",
            value=150.0,
            score=3.5,
            method=DetectionMethod.ZSCORE,
            severity=Severity.HIGH,
            threshold=3.0,
            explanation="Value exceeds 3 standard deviations",
            context={"zscore": 3.5},
            confidence=0.95
        )
        
        assert anomaly.timestamp == datetime(2023, 1, 1)
        assert anomaly.metric == "steps"
        assert anomaly.value == 150.0
        assert anomaly.score == 3.5
        assert anomaly.method == DetectionMethod.ZSCORE
        assert anomaly.severity == Severity.HIGH
        assert anomaly.confidence == 0.95
        assert anomaly.context["zscore"] == 3.5
        
    def test_detection_config(self):
        """Test DetectionConfig."""
        config = DetectionConfig(
            enabled_methods=[DetectionMethod.ZSCORE, DetectionMethod.ISOLATION_FOREST],
            zscore_threshold=3.0,
            isolation_forest_contamination=0.1,
            notification_enabled=True,
            adaptive_thresholds=True
        )
        
        assert len(config.enabled_methods) == 2
        assert config.zscore_threshold == 3.0
        assert config.isolation_forest_contamination == 0.1
        assert config.notification_enabled is True
        assert config.adaptive_thresholds is True
        
    def test_detection_result(self):
        """Test DetectionResult creation."""
        anomalies = [
            Anomaly(
                timestamp=datetime(2023, 1, 1),
                metric="steps",
                value=150.0,
                score=3.5,
                method=DetectionMethod.ZSCORE,
                severity=Severity.HIGH,
                confidence=0.95
            )
        ]
        
        result = DetectionResult(
            anomalies=anomalies,
            total_points=100,
            detection_time=0.5,
            method=DetectionMethod.ZSCORE,
            parameters={"threshold": 3.0}
        )
        
        assert len(result.anomalies) == 1
        assert result.total_points == 100
        assert result.anomaly_rate == 0.01
        assert result.detection_time == 0.5


class TestZScoreDetector:
    """Test ZScoreDetector class."""
    
    @pytest.fixture
    def sample_data(self):
        """Create sample data for testing."""
        dates = pd.date_range(start='2023-01-01', periods=100, freq='D')
        values = np.random.normal(100, 10, 100)
        # Add some anomalies
        values[25] = 200  # Spike
        values[50] = 20   # Drop
        values[75] = 180  # Another spike
        
        return pd.DataFrame({
            'date': dates,
            'value': values
        })
    
    def test_detector_initialization(self):
        """Test detector initialization."""
        detector = ZScoreDetector(threshold=3.0)
        assert detector is not None
        assert detector.threshold == 3.0
        
    def test_basic_anomaly_detection(self, sample_data):
        """Test basic anomaly detection."""
        detector = ZScoreDetector(threshold=3.0)
        
        anomalies = detector.detect(sample_data['value'].values)
        assert isinstance(anomalies, list)
        # Should detect the anomalies we added
        assert len(anomalies) >= 2
            
    def test_detect_with_dataframe(self, sample_data):
        """Test detection with pandas DataFrame."""
        detector = ZScoreDetector(threshold=3.0)
        
        # Test with DataFrame input
        anomalies = detector.detect(sample_data)
        assert isinstance(anomalies, list)
        
    def test_severity_mapping(self):
        """Test severity calculation based on z-score."""
        detector = ZScoreDetector(threshold=3.0)
        
        # Create data with specific z-scores
        data = np.array([0, 0, 0, 0, 15, 0, 0, 0, 0, -15])  # z-scores of ~3
        anomalies = detector.detect(data)
        
        assert len(anomalies) > 0
        for anomaly in anomalies:
            assert anomaly.severity in [Severity.HIGH, Severity.CRITICAL]


class TestIsolationForestDetector:
    """Test Isolation Forest detector."""
    
    @pytest.fixture
    def detector(self):
        """Create Isolation Forest detector."""
        return IsolationForestDetector(contamination=0.1)
    
    @pytest.fixture
    def normal_data(self):
        """Create normally distributed data."""
        np.random.seed(42)
        dates = pd.date_range(start='2023-01-01', periods=100, freq='D')
        values = np.random.normal(100, 10, 100)
        return pd.DataFrame({'date': dates, 'value': values})
    
    @pytest.fixture
    def anomalous_data(self):
        """Create data with anomalies."""
        np.random.seed(42)
        dates = pd.date_range(start='2023-01-01', periods=100, freq='D')
        values = np.random.normal(100, 10, 100)
        # Add clear anomalies
        values[10] = 250  # Very high spike
        values[20] = -50  # Very low drop
        values[30] = 200  # High spike
        return pd.DataFrame({'date': dates, 'value': values})
    
    def test_initialization(self, detector):
        """Test detector initialization."""
        assert detector.contamination == 0.1
        assert hasattr(detector, 'detect')
        
    def test_detect_no_anomalies(self, detector, normal_data):
        """Test detection with no anomalies."""
        anomalies = detector.detect(normal_data)
        assert len(anomalies) == 0
        
    def test_detect_with_anomalies(self, detector, anomalous_data):
        """Test detection with anomalies."""
        anomalies = detector.detect(anomalous_data)
        assert len(anomalies) > 0
        
        # Check first anomaly
        first_anomaly = anomalies[0]
        assert isinstance(first_anomaly, Anomaly)
        assert first_anomaly.method == DetectionMethod.ISOLATION_FOREST
        
    def test_custom_contamination(self, anomalous_data):
        """Test with different contamination rates."""
        # Higher contamination should find more anomalies
        detector_high = IsolationForestDetector(contamination=0.2)
        anomalies_high = detector_high.detect(anomalous_data['value'].values)
        
        # Lower contamination should find fewer anomalies
        detector_low = IsolationForestDetector(contamination=0.05)
        anomalies_low = detector_low.detect(anomalous_data['value'].values)
        
        assert len(anomalies_low) >= len(anomalies_high)


class TestIsolationForestDetector:
    """Test Isolation Forest detector."""
    
    @pytest.fixture
    def detector(self):
        """Create Isolation Forest detector."""
        return IsolationForestDetector(contamination=0.1)
    
    def test_initialization(self, detector):
        """Test detector initialization."""
        assert detector.contamination == 0.1
        assert detector.method == DetectionMethod.ISOLATION_FOREST
        
    def test_detect_anomalies(self, detector):
        """Test anomaly detection."""
        # Create data with clear outliers
        np.random.seed(42)
        dates = pd.date_range(start='2023-01-01', periods=100, freq='D')
        values = np.random.normal(100, 5, 100)
        # Add outliers
        values[10:15] = np.random.normal(200, 5, 5)
        
        data = pd.DataFrame({'date': dates, 'value': values})
        anomalies = detector.detect(data)
        
        assert len(anomalies) > 0
        assert all(isinstance(a, Anomaly) for a in anomalies)


class TestAnomalyDetectionSystem:
    """Test the complete anomaly detection system."""
    
    @pytest.fixture
    def system(self):
        """Create anomaly detection system."""
        config = AnomalyDetectionConfig(
            methods=[DetectionMethod.ZSCORE, DetectionMethod.ISOLATION_FOREST],
            sensitivity=0.8
        )
        return AnomalyDetectionSystem(config)
    
    @pytest.fixture
    def health_data(self):
        """Create realistic health data."""
        np.random.seed(42)
        dates = pd.date_range(start='2023-01-01', periods=365, freq='D')
        
        # Create realistic step data with weekly patterns
        base_steps = 8000
        weekly_pattern = np.tile([1.0, 1.1, 1.2, 1.1, 1.0, 0.8, 0.9], 53)[:365]
        noise = np.random.normal(0, 500, 365)
        steps = base_steps * weekly_pattern + noise
        
        # Add some anomalies
        steps[50] = 25000  # Very high day
        steps[100] = 1000  # Very low day
        steps[200:203] = 0  # Device off
        
        return pd.DataFrame({
            'date': dates,
            'value': steps,
            'type': 'steps'
        })
    
    def test_system_initialization(self, system):
        """Test system initialization."""
        assert len(system.config.methods) == 2
        assert system.config.sensitivity == 0.8
        assert len(system.detectors) == 2
        
    def test_detect_anomalies(self, system, health_data):
        """Test anomaly detection on health data."""
        anomalies = system.detect_anomalies(
            data=health_data,
            metric_type='steps'
        )
        
        assert len(anomalies) > 0
        assert all(isinstance(a, Anomaly) for a in anomalies)
        
        # Check that anomalies were found around the injected anomalous days
        anomaly_dates = [a.date for a in anomalies]
        # Should find the very high and very low days
        assert any(abs((d - health_data.iloc[50]['date']).days) < 2 for d in anomaly_dates)
        assert any(abs((d - health_data.iloc[100]['date']).days) < 2 for d in anomaly_dates)
        
    def test_generate_report(self, system, health_data):
        """Test report generation."""
        report = system.generate_report(
            data=health_data,
            metric_type='steps',
            period_start=date(2023, 1, 1),
            period_end=date(2023, 12, 31)
        )
        
        assert isinstance(report, AnomalyReport)
        assert report.metric_type == 'steps'
        assert len(report.anomalies) > 0
        assert 'total_anomalies' in report.summary_stats
        
    def test_ensemble_voting(self, system, health_data):
        """Test ensemble voting mechanism."""
        # Get anomalies from individual detectors
        all_anomalies = []
        for detector in system.detectors:
            anomalies = detector.detect(health_data)
            all_anomalies.extend(anomalies)
        
        # System should filter based on consensus
        system_anomalies = system.detect_anomalies(health_data, 'steps')
        
        # System anomalies should be subset of all anomalies
        assert len(system_anomalies) <= len(all_anomalies)
        
    def test_empty_data_handling(self, system):
        """Test handling of empty data."""
        empty_data = pd.DataFrame(columns=['date', 'value'])
        anomalies = system.detect_anomalies(empty_data, 'steps')
        assert len(anomalies) == 0
        
    def test_insufficient_data_handling(self, system):
        """Test handling of insufficient data."""
        small_data = pd.DataFrame({
            'date': pd.date_range('2023-01-01', periods=5),
            'value': [100, 102, 98, 101, 99]
        })
        anomalies = system.detect_anomalies(small_data, 'steps')
        # Should handle gracefully, possibly returning no anomalies
        assert isinstance(anomalies, list)


class TestEnsembleDetector:
    """Test ensemble anomaly detector."""
    
    @pytest.fixture
    def detector(self):
        """Create ensemble detector."""
        detectors = [
            ZScoreDetector(threshold=3.0),
            IsolationForestDetector(contamination=0.1)
        ]
        return EnsembleDetector(detectors=detectors, min_votes=1)
    
    def test_initialization(self, detector):
        """Test detector initialization."""
        assert len(detector.detectors) == 2
        assert detector.min_votes == 1
        
    def test_ensemble_detection(self, detector):
        """Test ensemble detection."""
        # Create data with clear anomaly
        dates = pd.date_range('2023-01-01', periods=50)
        values = np.random.normal(100, 5, 50)
        values[25] = 200  # Clear anomaly
        
        data = pd.DataFrame({'date': dates, 'value': values})
        anomalies = detector.detect(data)
        
        assert len(anomalies) > 0
        # The spike at index 25 should be detected
        anomaly_indices = [a.date for a in anomalies]
        assert dates[25].date() in anomaly_indices
        
    def test_voting_threshold(self):
        """Test different voting thresholds."""
        detectors = [
            ZScoreDetector(threshold=3.0),
            IsolationForestDetector(contamination=0.1),
            LOFDetector(contamination=0.1)
        ]
        
        # Require all detectors to agree
        strict_ensemble = EnsembleDetector(detectors=detectors, min_votes=3)
        
        # Require only one detector
        loose_ensemble = EnsembleDetector(detectors=detectors, min_votes=1)
        
        # Create test data
        dates = pd.date_range('2023-01-01', periods=50)
        values = np.random.normal(100, 5, 50)
        values[25] = 150  # Moderate anomaly
        data = pd.DataFrame({'date': dates, 'value': values})
        
        strict_anomalies = strict_ensemble.detect(data)
        loose_anomalies = loose_ensemble.detect(data)
        
        # Loose ensemble should find more or equal anomalies
        assert len(loose_anomalies) >= len(strict_anomalies)


class TestLOFDetector:
    """Test Local Outlier Factor detector."""
    
    @pytest.fixture
    def detector(self):
        """Create LOF detector."""
        return LOFDetector(contamination=0.1, n_neighbors=20)
    
    def test_initialization(self, detector):
        """Test detector initialization."""
        assert detector.contamination == 0.1
        assert detector.n_neighbors == 20
        assert detector.method == DetectionMethod.LOF
        
    def test_detect_local_outliers(self, detector):
        """Test detection of local outliers."""
        # Create data with local outliers
        np.random.seed(42)
        
        # Normal cluster
        cluster1 = np.random.normal(100, 5, 40)
        
        # Another normal cluster at different level
        cluster2 = np.random.normal(150, 5, 40)
        
        # Local outliers
        outliers = [125, 127, 175, 75]
        
        values = np.concatenate([cluster1, cluster2, outliers])
        dates = pd.date_range('2023-01-01', periods=len(values))
        
        data = pd.DataFrame({'date': dates, 'value': values})
        anomalies = detector.detect(data)
        
        assert len(anomalies) > 0
        assert all(isinstance(a, Anomaly) for a in anomalies)


def test_anomaly_detection_integration():
    """Test integration of anomaly detection components."""
    # Create realistic health data
    np.random.seed(42)
    dates = pd.date_range('2023-01-01', periods=180)
    
    # Simulate daily steps with weekend pattern
    steps = []
    for i, date in enumerate(dates):
        if date.weekday() < 5:  # Weekday
            base = 8000
        else:  # Weekend
            base = 6000
        
        # Add some randomness
        value = base + np.random.normal(0, 1000)
        
        # Add anomalies
        if i == 30:  # Sick day
            value = 500
        elif i == 60:  # Marathon day
            value = 25000
        elif i == 90:  # Forgot device
            value = 0
            
        steps.append(value)
    
    data = pd.DataFrame({
        'date': dates,
        'value': steps,
        'type': 'steps'
    })
    
    # Create detection system
    config = AnomalyDetectionConfig(
        methods=[
            DetectionMethod.ZSCORE,
            DetectionMethod.ISOLATION_FOREST,
            DetectionMethod.LOF
        ],
        sensitivity=0.7,
        min_data_points=30
    )
    
    system = AnomalyDetectionSystem(config)
    
    # Detect anomalies
    anomalies = system.detect_anomalies(data, 'steps')
    
    # Should detect the three injected anomalies
    assert len(anomalies) >= 3
    
    # Generate report
    report = system.generate_report(
        data=data,
        metric_type='steps',
        period_start=dates[0].date(),
        period_end=dates[-1].date()
    )
    
    assert report.metric_type == 'steps'
    assert len(report.anomalies) >= 3
    assert report.summary_stats['total_anomalies'] >= 3
    
    # Check severity distribution
    severities = [a.severity for a in report.anomalies]
    assert any(s == AnomalySeverity.HIGH or s == AnomalySeverity.CRITICAL for s in severities)