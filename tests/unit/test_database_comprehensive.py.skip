"""Comprehensive tests for database module."""

import pytest
from datetime import date, datetime, timedelta
from unittest.mock import Mock, patch, MagicMock
import sqlite3
import pandas as pd
import numpy as np
import os
import tempfile
import threading
import time

from src.database import db_manager
from src.utils.error_handler import DatabaseError


class TestDatabaseManager:
    """Test database manager functionality."""
    
    @pytest.fixture
    def temp_db_path(self):
        """Create temporary database path."""
        with tempfile.NamedTemporaryFile(suffix='.db', delete=False) as f:
            db_path = f.name
        yield db_path
        if os.path.exists(db_path):
            os.unlink(db_path)
    
    @pytest.fixture
    def db_manager(self, temp_db_path, monkeypatch):
        """Create database manager with temporary database."""
        # Patch the database path
        monkeypatch.setattr('src.database.config.DATABASE_PATH', temp_db_path)
        
        # Reset singleton instance
        DatabaseManager._instance = None
        
        manager = DatabaseManager()
        yield manager
        
        # Cleanup
        DatabaseManager._instance = None
    
    def test_singleton_pattern(self, db_manager):
        """Test that DatabaseManager follows singleton pattern."""
        manager1 = DatabaseManager()
        manager2 = DatabaseManager()
        
        assert manager1 is manager2
        assert manager1 is db_manager
    
    def test_database_initialization(self, db_manager):
        """Test database initialization creates tables."""
        # Get connection to check tables
        with db_manager.get_connection() as conn:
            cursor = conn.cursor()
            
            # Check if tables exist
            cursor.execute("""
                SELECT name FROM sqlite_master 
                WHERE type='table' AND name='journal_entries'
            """)
            assert cursor.fetchone() is not None
            
            cursor.execute("""
                SELECT name FROM sqlite_master 
                WHERE type='table' AND name='goals'
            """)
            assert cursor.fetchone() is not None
    
    def test_get_connection(self, db_manager):
        """Test getting database connection."""
        with db_manager.get_connection() as conn:
            assert conn is not None
            assert isinstance(conn, sqlite3.Connection)
            
            # Test that connection works
            cursor = conn.cursor()
            cursor.execute("SELECT 1")
            assert cursor.fetchone()[0] == 1
    
    def test_execute_query(self, db_manager):
        """Test executing queries."""
        # Insert test data
        result = db_manager.execute_query(
            "INSERT INTO journal_entries (date, content) VALUES (?, ?)",
            (datetime.now().isoformat(), "Test entry")
        )
        assert result is not None
        
        # Select data
        rows = db_manager.execute_query(
            "SELECT content FROM journal_entries WHERE content = ?",
            ("Test entry",),
            fetchall=True
        )
        assert len(rows) == 1
        assert rows[0][0] == "Test entry"
    
    def test_execute_many(self, db_manager):
        """Test executing many queries."""
        # Prepare test data
        entries = [
            (f"2024-01-{i:02d}", f"Entry {i}")
            for i in range(1, 11)
        ]
        
        # Insert multiple entries
        db_manager.execute_many(
            "INSERT INTO journal_entries (date, content) VALUES (?, ?)",
            entries
        )
        
        # Verify insertion
        rows = db_manager.execute_query(
            "SELECT COUNT(*) FROM journal_entries",
            fetchall=True
        )
        assert rows[0][0] >= 10
    
    def test_transaction_commit(self, db_manager):
        """Test transaction commit."""
        with db_manager.transaction() as conn:
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO journal_entries (date, content) VALUES (?, ?)",
                (datetime.now().isoformat(), "Transaction test")
            )
        
        # Verify data was committed
        rows = db_manager.execute_query(
            "SELECT content FROM journal_entries WHERE content = ?",
            ("Transaction test",),
            fetchall=True
        )
        assert len(rows) == 1
    
    def test_transaction_rollback(self, db_manager):
        """Test transaction rollback on error."""
        try:
            with db_manager.transaction() as conn:
                cursor = conn.cursor()
                cursor.execute(
                    "INSERT INTO journal_entries (date, content) VALUES (?, ?)",
                    (datetime.now().isoformat(), "Rollback test")
                )
                # Force an error
                raise Exception("Test error")
        except Exception:
            pass
        
        # Verify data was not committed
        rows = db_manager.execute_query(
            "SELECT content FROM journal_entries WHERE content = ?",
            ("Rollback test",),
            fetchall=True
        )
        assert len(rows) == 0
    
    def test_concurrent_access(self, db_manager):
        """Test concurrent database access."""
        results = []
        errors = []
        
        def worker(worker_id):
            try:
                for i in range(10):
                    db_manager.execute_query(
                        "INSERT INTO journal_entries (date, content) VALUES (?, ?)",
                        (f"2024-01-{worker_id:02d}", f"Worker {worker_id} Entry {i}")
                    )
                    time.sleep(0.001)  # Small delay to increase concurrency
                results.append(worker_id)
            except Exception as e:
                errors.append((worker_id, str(e)))
        
        # Create multiple threads
        threads = []
        for i in range(5):
            t = threading.Thread(target=worker, args=(i,))
            threads.append(t)
            t.start()
        
        # Wait for all threads
        for t in threads:
            t.join()
        
        # Check results
        assert len(results) == 5
        assert len(errors) == 0
        
        # Verify all entries were inserted
        rows = db_manager.execute_query(
            "SELECT COUNT(*) FROM journal_entries",
            fetchall=True
        )
        assert rows[0][0] >= 50
    
    def test_database_backup(self, db_manager, temp_db_path):
        """Test database backup functionality."""
        # Insert some data
        db_manager.execute_query(
            "INSERT INTO journal_entries (date, content) VALUES (?, ?)",
            (datetime.now().isoformat(), "Backup test")
        )
        
        # Create backup
        backup_path = temp_db_path + ".backup"
        db_manager.backup_database(backup_path)
        
        assert os.path.exists(backup_path)
        
        # Verify backup contains data
        backup_conn = sqlite3.connect(backup_path)
        cursor = backup_conn.cursor()
        cursor.execute("SELECT content FROM journal_entries WHERE content = ?", ("Backup test",))
        assert cursor.fetchone() is not None
        backup_conn.close()
        
        # Cleanup
        os.unlink(backup_path)
    
    def test_vacuum_database(self, db_manager):
        """Test database vacuum operation."""
        # Insert and delete data to create fragmentation
        for i in range(100):
            db_manager.execute_query(
                "INSERT INTO journal_entries (date, content) VALUES (?, ?)",
                (f"2024-01-{i:02d}", f"Entry {i}")
            )
        
        db_manager.execute_query("DELETE FROM journal_entries WHERE 1=1")
        
        # Get size before vacuum
        initial_size = os.path.getsize(db_manager.db_path)
        
        # Vacuum database
        db_manager.vacuum()
        
        # Size should be reduced (or at least not larger)
        final_size = os.path.getsize(db_manager.db_path)
        assert final_size <= initial_size
    
    def test_get_table_info(self, db_manager):
        """Test getting table information."""
        info = db_manager.get_table_info('journal_entries')
        
        assert len(info) > 0
        column_names = [col[1] for col in info]
        assert 'id' in column_names
        assert 'date' in column_names
        assert 'content' in column_names
    
    def test_table_exists(self, db_manager):
        """Test checking if table exists."""
        assert db_manager.table_exists('journal_entries') is True
        assert db_manager.table_exists('non_existent_table') is False
    
    def test_create_index(self, db_manager):
        """Test creating database index."""
        # Create index
        db_manager.create_index('idx_journal_date', 'journal_entries', ['date'])
        
        # Verify index exists
        with db_manager.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT name FROM sqlite_master 
                WHERE type='index' AND name='idx_journal_date'
            """)
            assert cursor.fetchone() is not None
    
    def test_error_handling(self, db_manager):
        """Test error handling in database operations."""
        # Test invalid query
        with pytest.raises(DatabaseError):
            db_manager.execute_query("SELECT * FROM non_existent_table")
        
        # Test invalid column
        with pytest.raises(DatabaseError):
            db_manager.execute_query(
                "INSERT INTO journal_entries (invalid_column) VALUES (?)",
                ("test",)
            )


class TestHealthDatabase:
    """Test health database functionality."""
    
    @pytest.fixture
    def health_db(self, db_manager):
        """Create health database instance."""
        return health_database
    
    def test_save_health_data(self, health_db):
        """Test saving health data."""
        success = health_db.save_health_data(
            user_id=1,
            data_type='steps',
            value=10000,
            unit='count',
            timestamp=datetime.now()
        )
        assert success is True
    
    def test_get_health_data(self, health_db):
        """Test retrieving health data."""
        # Save test data
        timestamp = datetime.now()
        health_db.save_health_data(
            user_id=1,
            data_type='steps',
            value=8500,
            unit='count',
            timestamp=timestamp
        )
        
        # Retrieve data
        data = health_db.get_health_data(
            user_id=1,
            data_type='steps',
            start_date=timestamp - timedelta(days=1),
            end_date=timestamp + timedelta(days=1)
        )
        
        assert len(data) == 1
        assert data[0]['value'] == 8500
    
    def test_save_journal_entry(self, health_db):
        """Test saving journal entry."""
        entry_id = health_db.save_journal_entry(
            user_id=1,
            date=date.today(),
            content="Test journal entry",
            mood_score=8,
            tags=['test', 'health']
        )
        assert entry_id is not None
    
    def test_get_journal_entries(self, health_db):
        """Test retrieving journal entries."""
        # Save test entry
        today = date.today()
        health_db.save_journal_entry(
            user_id=1,
            date=today,
            content="Test entry",
            mood_score=7
        )
        
        # Retrieve entries
        entries = health_db.get_journal_entries(
            user_id=1,
            start_date=today - timedelta(days=1),
            end_date=today + timedelta(days=1)
        )
        
        assert len(entries) == 1
        assert entries[0]['content'] == "Test entry"
    
    def test_save_goal(self, health_db):
        """Test saving health goal."""
        goal_id = health_db.save_goal(
            user_id=1,
            goal_type='steps',
            target_value=10000,
            frequency='daily',
            start_date=date.today()
        )
        assert goal_id is not None
    
    def test_get_active_goals(self, health_db):
        """Test retrieving active goals."""
        # Save test goal
        health_db.save_goal(
            user_id=1,
            goal_type='steps',
            target_value=10000,
            frequency='daily',
            start_date=date.today()
        )
        
        # Retrieve active goals
        goals = health_db.get_active_goals(user_id=1)
        
        assert len(goals) > 0
        assert goals[0]['goal_type'] == 'steps'
        assert goals[0]['target_value'] == 10000
    
    def test_update_goal_progress(self, health_db):
        """Test updating goal progress."""
        # Create goal
        goal_id = health_db.save_goal(
            user_id=1,
            goal_type='steps',
            target_value=10000,
            frequency='daily',
            start_date=date.today()
        )
        
        # Update progress
        success = health_db.update_goal_progress(
            goal_id=goal_id,
            progress_value=7500,
            progress_date=date.today()
        )
        assert success is True
    
    def test_get_health_summary(self, health_db):
        """Test getting health data summary."""
        # Save various health data
        base_time = datetime.now()
        for i in range(7):
            health_db.save_health_data(
                user_id=1,
                data_type='steps',
                value=8000 + i * 500,
                unit='count',
                timestamp=base_time - timedelta(days=i)
            )
        
        # Get summary
        summary = health_db.get_health_summary(
            user_id=1,
            data_type='steps',
            period_days=7
        )
        
        assert summary['count'] == 7
        assert summary['average'] > 0
        assert summary['min'] >= 8000
        assert summary['max'] <= 11000
    
    def test_data_validation(self, health_db):
        """Test data validation in health database."""
        # Test invalid data type
        with pytest.raises(ValueError):
            health_db.save_health_data(
                user_id=1,
                data_type='',  # Empty data type
                value=100,
                unit='count',
                timestamp=datetime.now()
            )
        
        # Test invalid value
        with pytest.raises(ValueError):
            health_db.save_health_data(
                user_id=1,
                data_type='steps',
                value=-100,  # Negative steps
                unit='count',
                timestamp=datetime.now()
            )
    
    def test_bulk_insert(self, health_db):
        """Test bulk data insertion."""
        # Prepare bulk data
        data_points = []
        base_time = datetime.now()
        
        for i in range(1000):
            data_points.append({
                'user_id': 1,
                'data_type': 'heart_rate',
                'value': 60 + (i % 20),
                'unit': 'bpm',
                'timestamp': base_time - timedelta(minutes=i)
            })
        
        # Bulk insert
        import time
        start_time = time.time()
        success = health_db.bulk_insert_health_data(data_points)
        elapsed = time.time() - start_time
        
        assert success is True
        assert elapsed < 1.0  # Should complete within 1 second
        
        # Verify insertion
        count = health_db.get_health_data_count(
            user_id=1,
            data_type='heart_rate'
        )
        assert count == 1000
    
    def test_data_export(self, health_db):
        """Test exporting health data."""
        # Save test data
        for i in range(30):
            health_db.save_health_data(
                user_id=1,
                data_type='steps',
                value=8000 + i * 100,
                unit='count',
                timestamp=datetime.now() - timedelta(days=i)
            )
        
        # Export to DataFrame
        df = health_db.export_to_dataframe(
            user_id=1,
            data_type='steps',
            start_date=datetime.now() - timedelta(days=30)
        )
        
        assert isinstance(df, pd.DataFrame)
        assert len(df) == 30
        assert 'value' in df.columns
        assert 'timestamp' in df.columns
    
    def test_data_aggregation(self, health_db):
        """Test data aggregation queries."""
        # Save hourly data
        base_time = datetime.now().replace(minute=0, second=0, microsecond=0)
        
        for hour in range(24):
            health_db.save_health_data(
                user_id=1,
                data_type='heart_rate',
                value=70 + (hour % 10),
                unit='bpm',
                timestamp=base_time - timedelta(hours=hour)
            )
        
        # Aggregate by hour
        hourly_avg = health_db.aggregate_health_data(
            user_id=1,
            data_type='heart_rate',
            aggregation='avg',
            group_by='hour',
            start_date=base_time - timedelta(days=1)
        )
        
        assert len(hourly_avg) > 0
        assert all(60 <= avg <= 80 for avg in hourly_avg.values())
    
    def test_cleanup_old_data(self, health_db):
        """Test cleaning up old data."""
        # Save old data
        old_time = datetime.now() - timedelta(days=400)
        
        for i in range(100):
            health_db.save_health_data(
                user_id=1,
                data_type='steps',
                value=8000,
                unit='count',
                timestamp=old_time - timedelta(days=i)
            )
        
        # Clean up data older than 365 days
        deleted_count = health_db.cleanup_old_data(days_to_keep=365)
        
        assert deleted_count > 0
        
        # Verify old data is gone
        old_data = health_db.get_health_data(
            user_id=1,
            start_date=old_time - timedelta(days=100),
            end_date=old_time
        )
        assert len(old_data) == 0