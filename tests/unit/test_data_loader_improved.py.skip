"""Improved tests for data loader module."""

import pytest
import os
import tempfile
import sqlite3
import xml.etree.ElementTree as ET
from datetime import datetime, date
from unittest.mock import Mock, patch, mock_open
import pandas as pd

from src.data_loader import (
    convert_xml_to_sqlite_with_validation,
    load_csv_data,
    migrate_csv_to_sqlite,
    query_date_range,
    get_daily_summary,
    get_available_types,
    validate_database
)
from src.utils.error_handler import DataImportError, DataValidationError


class TestXmlToSqliteConversion:
    """Test XML to SQLite conversion functionality."""
    
    @pytest.fixture
    def temp_files(self):
        """Create temporary files for testing."""
        with tempfile.NamedTemporaryFile(suffix='.xml', delete=False) as xml_file:
            xml_path = xml_file.name
        with tempfile.NamedTemporaryFile(suffix='.db', delete=False) as db_file:
            db_path = db_file.name
            
        yield xml_path, db_path
        
        # Cleanup
        for path in [xml_path, db_path]:
            if os.path.exists(path):
                os.unlink(path)
    
    def test_convert_valid_xml(self, temp_files):
        """Test converting valid XML to SQLite."""
        xml_path, db_path = temp_files
        
        # Create valid XML content
        xml_content = '''<?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE HealthData>
        <HealthData locale="en_US">
            <Record type="HKQuantityTypeIdentifierStepCount" 
                    sourceName="iPhone" 
                    unit="count" 
                    creationDate="2024-01-01 10:00:00 +0000" 
                    startDate="2024-01-01 08:00:00 +0000" 
                    endDate="2024-01-01 09:00:00 +0000" 
                    value="1523"/>
            <Record type="HKQuantityTypeIdentifierHeartRate" 
                    sourceName="Apple Watch" 
                    unit="count/min" 
                    creationDate="2024-01-01 10:30:00 +0000" 
                    startDate="2024-01-01 10:30:00 +0000" 
                    endDate="2024-01-01 10:30:00 +0000" 
                    value="72"/>
        </HealthData>'''
        
        with open(xml_path, 'w') as f:
            f.write(xml_content)
        
        # Convert without validation to test the actual conversion
        count, summary = convert_xml_to_sqlite_with_validation(
            xml_path, db_path, validate_first=False
        )
        
        assert count == 2
        assert "successfully" in summary.lower()
        
        # Verify database content
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM health_records")
        assert cursor.fetchone()[0] == 2
        
        # Check specific record
        cursor.execute(
            "SELECT type, value, unit FROM health_records WHERE type = ?",
            ("HKQuantityTypeIdentifierStepCount",)
        )
        row = cursor.fetchone()
        assert row[0] == "HKQuantityTypeIdentifierStepCount"
        assert row[1] == 1523.0
        assert row[2] == "count"
        
        conn.close()
    
    def test_convert_with_validation(self, temp_files):
        """Test conversion with XML validation."""
        xml_path, db_path = temp_files
        
        # Create minimal valid XML
        xml_content = '''<?xml version="1.0" encoding="UTF-8"?>
        <HealthData locale="en_US">
            <Record type="HKQuantityTypeIdentifierStepCount" 
                    value="5000" unit="count"
                    startDate="2024-01-01 10:00:00 +0000" 
                    endDate="2024-01-01 11:00:00 +0000"/>
        </HealthData>'''
        
        with open(xml_path, 'w') as f:
            f.write(xml_content)
        
        with patch('src.data_loader.validate_apple_health_xml') as mock_validate:
            mock_validate.return_value = (True, [])
            
            count, summary = convert_xml_to_sqlite_with_validation(
                xml_path, db_path, validate_first=True
            )
            
            mock_validate.assert_called_once_with(xml_path)
            assert count > 0
    
    def test_convert_invalid_xml_file_not_found(self, temp_files):
        """Test handling of missing XML file."""
        _, db_path = temp_files
        non_existent = "/path/does/not/exist.xml"
        
        with pytest.raises(FileNotFoundError):
            convert_xml_to_sqlite_with_validation(non_existent, db_path)
    
    def test_convert_malformed_xml(self, temp_files):
        """Test handling of malformed XML."""
        xml_path, db_path = temp_files
        
        # Write malformed XML
        with open(xml_path, 'w') as f:
            f.write("<Invalid>Not properly formed XML")
        
        with pytest.raises(ET.ParseError):
            convert_xml_to_sqlite_with_validation(
                xml_path, db_path, validate_first=False
            )
    
    def test_convert_large_batch_processing(self, temp_files):
        """Test batch processing of large XML."""
        xml_path, db_path = temp_files
        
        # Create XML with many records
        with open(xml_path, 'w') as f:
            f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
            f.write('<HealthData locale="en_US">\n')
            
            # Write 1000 records
            for i in range(1000):
                f.write(f'''    <Record type="HKQuantityTypeIdentifierStepCount" 
                        value="{5000 + i}" unit="count"
                        startDate="2024-01-01 {i % 24:02d}:00:00 +0000" 
                        endDate="2024-01-01 {i % 24:02d}:30:00 +0000"/>\n''')
            
            f.write('</HealthData>')
        
        count, summary = convert_xml_to_sqlite_with_validation(
            xml_path, db_path, validate_first=False
        )
        
        assert count == 1000
        assert "1000" in summary


class TestCsvDataLoading:
    """Test CSV data loading functionality."""
    
    @pytest.fixture
    def sample_csv_path(self):
        """Create sample CSV file."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as f:
            f.write("Type,Value,Unit,Start,End\n")
            f.write("HKQuantityTypeIdentifierStepCount,8543,count,2024-01-01 08:00:00,2024-01-01 20:00:00\n")
            f.write("HKQuantityTypeIdentifierHeartRate,72,count/min,2024-01-01 10:00:00,2024-01-01 10:00:00\n")
            f.write("HKQuantityTypeIdentifierDistanceWalkingRunning,5.2,km,2024-01-01 08:00:00,2024-01-01 20:00:00\n")
            csv_path = f.name
        
        yield csv_path
        
        if os.path.exists(csv_path):
            os.unlink(csv_path)
    
    def test_load_csv_success(self, sample_csv_path):
        """Test successful CSV loading."""
        df = load_csv_data(sample_csv_path)
        
        assert isinstance(df, pd.DataFrame)
        assert len(df) == 3
        assert 'Type' in df.columns
        assert 'Value' in df.columns
        assert df.iloc[0]['Type'] == 'HKQuantityTypeIdentifierStepCount'
        assert df.iloc[0]['Value'] == 8543
    
    def test_load_csv_file_not_found(self):
        """Test loading non-existent CSV."""
        with pytest.raises(FileNotFoundError):
            load_csv_data("/path/does/not/exist.csv")
    
    def test_load_csv_empty_file(self):
        """Test loading empty CSV."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as f:
            f.write("")  # Empty file
            csv_path = f.name
        
        try:
            df = load_csv_data(csv_path)
            assert len(df) == 0
        finally:
            os.unlink(csv_path)


class TestCsvToSqliteMigration:
    """Test CSV to SQLite migration."""
    
    @pytest.fixture
    def migration_files(self):
        """Create files for migration testing."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as csv_file:
            csv_file.write("Type,Value,Unit,Start,End,Source\n")
            csv_file.write("HKQuantityTypeIdentifierStepCount,10000,count,2024-01-01 08:00:00,2024-01-01 20:00:00,iPhone\n")
            csv_file.write("HKQuantityTypeIdentifierActiveEnergyBurned,450,kcal,2024-01-01 08:00:00,2024-01-01 20:00:00,Apple Watch\n")
            csv_path = csv_file.name
            
        with tempfile.NamedTemporaryFile(suffix='.db', delete=False) as db_file:
            db_path = db_file.name
        
        yield csv_path, db_path
        
        for path in [csv_path, db_path]:
            if os.path.exists(path):
                os.unlink(path)
    
    def test_migrate_csv_to_sqlite(self, migration_files):
        """Test migrating CSV data to SQLite."""
        csv_path, db_path = migration_files
        
        count = migrate_csv_to_sqlite(csv_path, db_path)
        
        assert count == 2
        
        # Verify migration
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM health_records")
        assert cursor.fetchone()[0] == 2
        
        cursor.execute("SELECT type, value FROM health_records ORDER BY value DESC")
        rows = cursor.fetchall()
        assert rows[0][0] == "HKQuantityTypeIdentifierStepCount"
        assert rows[0][1] == 10000.0
        conn.close()


class TestDatabaseQueries:
    """Test database query functions."""
    
    @pytest.fixture
    def populated_db(self):
        """Create populated test database."""
        with tempfile.NamedTemporaryFile(suffix='.db', delete=False) as f:
            db_path = f.name
        
        conn = sqlite3.connect(db_path)
        conn.execute("""
            CREATE TABLE IF NOT EXISTS health_records (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                type TEXT NOT NULL,
                value REAL NOT NULL,
                unit TEXT,
                start_date TEXT NOT NULL,
                end_date TEXT,
                source_name TEXT,
                creation_date TEXT
            )
        """)
        
        # Insert test data
        test_data = [
            ("HKQuantityTypeIdentifierStepCount", 8000, "count", 
             "2024-01-01 08:00:00", "2024-01-01 20:00:00", "iPhone"),
            ("HKQuantityTypeIdentifierStepCount", 9500, "count", 
             "2024-01-02 08:00:00", "2024-01-02 20:00:00", "iPhone"),
            ("HKQuantityTypeIdentifierHeartRate", 72, "count/min", 
             "2024-01-01 10:00:00", "2024-01-01 10:00:00", "Apple Watch"),
            ("HKQuantityTypeIdentifierHeartRate", 68, "count/min", 
             "2024-01-02 10:00:00", "2024-01-02 10:00:00", "Apple Watch"),
        ]
        
        conn.executemany(
            "INSERT INTO health_records (type, value, unit, start_date, end_date, source_name) "
            "VALUES (?, ?, ?, ?, ?, ?)",
            test_data
        )
        conn.commit()
        conn.close()
        
        yield db_path
        
        os.unlink(db_path)
    
    def test_query_date_range(self, populated_db):
        """Test querying by date range."""
        records = query_date_range(
            populated_db,
            start_date="2024-01-01",
            end_date="2024-01-01",
            record_type="HKQuantityTypeIdentifierStepCount"
        )
        
        assert len(records) == 1
        assert records[0]['value'] == 8000
        assert records[0]['type'] == "HKQuantityTypeIdentifierStepCount"
    
    def test_query_all_types(self, populated_db):
        """Test querying all record types."""
        records = query_date_range(
            populated_db,
            start_date="2024-01-01",
            end_date="2024-01-02"
        )
        
        assert len(records) == 4
        types = [r['type'] for r in records]
        assert "HKQuantityTypeIdentifierStepCount" in types
        assert "HKQuantityTypeIdentifierHeartRate" in types
    
    def test_get_daily_summary(self, populated_db):
        """Test getting daily summary."""
        summary = get_daily_summary(populated_db, "2024-01-01")
        
        assert summary is not None
        assert 'total_records' in summary
        assert 'types' in summary
        assert summary['total_records'] == 2
        assert len(summary['types']) == 2
    
    def test_get_available_types(self, populated_db):
        """Test getting available record types."""
        types = get_available_types(populated_db)
        
        assert len(types) == 2
        assert "HKQuantityTypeIdentifierStepCount" in types
        assert "HKQuantityTypeIdentifierHeartRate" in types
    
    def test_validate_database(self, populated_db):
        """Test database validation."""
        is_valid, message = validate_database(populated_db)
        
        assert is_valid is True
        assert "valid" in message.lower()
    
    def test_validate_invalid_database(self):
        """Test validation of invalid database."""
        with tempfile.NamedTemporaryFile(suffix='.db', delete=False) as f:
            f.write(b"Not a valid SQLite database")
            db_path = f.name
        
        try:
            is_valid, message = validate_database(db_path)
            assert is_valid is False
            assert "error" in message.lower() or "invalid" in message.lower()
        finally:
            os.unlink(db_path)


class TestErrorHandling:
    """Test error handling in data loader."""
    
    def test_handle_permission_error(self):
        """Test handling of permission errors."""
        with patch('builtins.open', side_effect=PermissionError("Access denied")):
            with pytest.raises(PermissionError):
                load_csv_data("test.csv")
    
    def test_handle_database_corruption(self, temp_files):
        """Test handling of corrupted database."""
        xml_path, db_path = temp_files
        
        # Create valid XML
        with open(xml_path, 'w') as f:
            f.write('<?xml version="1.0" encoding="UTF-8"?><HealthData></HealthData>')
        
        # Mock database error during conversion
        with patch('sqlite3.connect', side_effect=sqlite3.DatabaseError("Corrupted")):
            with pytest.raises(sqlite3.DatabaseError):
                convert_xml_to_sqlite_with_validation(xml_path, db_path, validate_first=False)
    
    def test_handle_memory_error(self):
        """Test handling of memory errors."""
        with patch('pandas.read_csv', side_effect=MemoryError("Out of memory")):
            with pytest.raises(MemoryError):
                load_csv_data("large_file.csv")